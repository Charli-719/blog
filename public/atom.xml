<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lifuzhen</title>
  <icon>https://www.gravatar.com/avatar/a9f20b334b612fb41766f27517bdfacb</icon>
  <subtitle>梦想的起源</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://Lifuzhen.github.io/"/>
  <updated>2019-06-22T07:05:01.117Z</updated>
  <id>https://Lifuzhen.github.io/</id>
  
  <author>
    <name>lifuzhen</name>
    <email>1342786307@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react实现抽奖大转盘</title>
    <link href="https://Lifuzhen.github.io/2019/06/22/react%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%A5%96%E5%A4%A7%E8%BD%AC%E7%9B%98/"/>
    <id>https://Lifuzhen.github.io/2019/06/22/react实现抽奖大转盘/</id>
    <published>2019-06-22T07:00:48.000Z</published>
    <updated>2019-06-22T07:05:01.117Z</updated>
    
    <content type="html"><![CDATA[<p>先看一下实现的效果（这样才有动力）<br><img src="/2019/06/22/react实现抽奖大转盘/01.gif" alt="最后实现效果图"></p><a id="more"></a><p>1、html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas className=&quot;item&quot; id=&quot;wheelcanvas&quot; height=&#123;422&#125; width=&#123;422&#125;/&gt;</span><br></pre></td></tr></table></figure></p><p>2、绘制圆盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let canvas = document.getElementById(&quot;wheelcanvas&quot;);</span><br><span class="line">// 获取canvas的上下文,context含有各种api用来操作canvas</span><br><span class="line">let context = canvas.getContext(&apos;2d&apos;);</span><br><span class="line">this.setState(&#123;canvas: canvas, context: context&#125;);</span><br><span class="line">context.save();</span><br><span class="line">// 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置</span><br><span class="line">// 保证了当前的绘制不会影响到之前的绘制</span><br><span class="line">context.beginPath();</span><br><span class="line">// 设置填充转盘用的颜色,fill是填充而不是绘制</span><br><span class="line">context.fillStyle = &apos;#fff&apos;;</span><br><span class="line">// 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针)</span><br><span class="line">context.arc(211, 211, 211, startRadian, Math.PI * 2 + startRadian, false);</span><br><span class="line">// 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效.</span><br><span class="line">context.fill();</span><br><span class="line">// 将画布的状态恢复到上一次save()时的状态</span><br><span class="line">context.restore();</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/22/react实现抽奖大转盘/02.jpg" alt=""><br>2、绘制奖品<br>canvas绘制都是从水平出开始绘制，所以这里我调整了初始弧度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">let awards = [</span><br><span class="line">&#123;id: 1, name: &apos;一等奖&apos;, level: &apos;1&apos;, color:&quot;#FFC200&quot;&#125;,</span><br><span class="line">   &#123;id: 2, name: &apos;二等奖&apos;, level: &apos;2&apos;, color:&quot;#FFE122&quot;&#125;,</span><br><span class="line">   &#123;id: 3, name: &apos;三等奖&apos;, level: &apos;3&apos;, color:&quot;#FFC200&quot;&#125;,</span><br><span class="line">    &#123;id: 4, name: &apos;四等奖&apos;, level: &apos;4&apos;, color:&quot;#FFE122&quot;&#125;,</span><br><span class="line">    &#123;id: 5, name: &apos;五等奖&apos;, level: &apos;5&apos;, color:&quot;#FFC200&quot;&#125;,</span><br><span class="line">    &#123;id: 6, name: &apos;六等奖&apos;, level: &apos;6&apos;, color:&quot;#FFE122&quot;&#125;,</span><br><span class="line">],//大转盘要绘制的奖品</span><br><span class="line">let startRadian = -90 * Math.PI / 180,//大转盘的开始弧度(canvas绘制圆从水平方向开始，所以这里调整为垂直方向) 弧度计算公式：角度*Math.PI/180</span><br><span class="line">// 第一个奖品色块开始绘制时开始的弧度及结束的弧度</span><br><span class="line">   let RadianGap = Math.PI * 2 / awards.length, endRadian = startRadian + RadianGap;</span><br><span class="line">   for (let i = 0; i &lt; awards.length; i++) &#123;</span><br><span class="line">     context.save();</span><br><span class="line">     context.beginPath();</span><br><span class="line">     // 为了区分不同的色块,使用随机生成的颜色作为色块的填充色</span><br><span class="line">     context.fillStyle = awards[i].color;</span><br><span class="line">     // 这里需要使用moveTo方法将初始位置定位在圆点处,这样绘制的圆弧都会以圆点作为闭合点</span><br><span class="line">     context.moveTo(211, 211);</span><br><span class="line">     // 画圆弧时,每次都会自动调用moveTo,将画笔移动到圆弧的起点,半径设置的比转盘稍小一点</span><br><span class="line">     context.arc(211, 211, 201, startRadian, endRadian, false);</span><br><span class="line">     context.fill();</span><br><span class="line">     context.restore();</span><br><span class="line">     // 开始绘制文字</span><br><span class="line">     context.save();</span><br><span class="line">     //设置文字颜色</span><br><span class="line">     context.fillStyle = &apos;#f00&apos;;</span><br><span class="line">     //设置文字样式</span><br><span class="line">     context.font = &quot;18px Arial&quot;;</span><br><span class="line">     // 改变canvas原点的位置,简单来说,translate到哪个坐标点,那么那个坐标点就将变为坐标(0, 0)</span><br><span class="line">     context.translate(</span><br><span class="line">       211 + Math.cos(startRadian + RadianGap / 2) * 201,</span><br><span class="line">       211 + Math.sin(startRadian + RadianGap / 2) * 201</span><br><span class="line">     );</span><br><span class="line">     // 旋转角度,这个旋转是相对于原点进行旋转的.</span><br><span class="line">     context.rotate(startRadian + RadianGap / 2 + Math.PI / 2);</span><br><span class="line">     // 这里就是根据获取的各行的文字进行绘制,maxLineWidth取70,相当与一行最多展示5个文字</span><br><span class="line">     this.getLineTextList(context, awards[i].name, 70).forEach((line, index) =&gt; &#123;</span><br><span class="line">       // 绘制文字的方法,三个参数分别带:要绘制的文字,开始绘制的x坐标,开始绘制的y坐标</span><br><span class="line">       context.fillText(line, -context.measureText(line).width / 2, ++index * 25)</span><br><span class="line">     &#125;);</span><br><span class="line">     context.restore();</span><br><span class="line">     // 每个奖品色块绘制完后,下个奖品的弧度会递增</span><br><span class="line">     startRadian += RadianGap;</span><br><span class="line">     endRadian += RadianGap;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//绘制文字，文字过长进行换行，防止文字溢出</span><br><span class="line">  getLineTextList(context, text, maxLineWidth) &#123;</span><br><span class="line">    let wordList = text.split(&apos;&apos;), tempLine = &apos;&apos;, lineList = [];</span><br><span class="line">    for (let i = 0; i &lt; wordList.length; i++) &#123;</span><br><span class="line">      if (context.measureText(tempLine).width &gt;= maxLineWidth) &#123;</span><br><span class="line">        lineList.push(tempLine);</span><br><span class="line">        maxLineWidth -= context.measureText(text[0]).width;</span><br><span class="line">        tempLine = &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">      tempLine += wordList[i]</span><br><span class="line">    &#125;</span><br><span class="line">    lineList.push(tempLine);</span><br><span class="line">    return lineList</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/22/react实现抽奖大转盘/03.jpg" alt=""><br>3、绘制中间的小圆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//下面是画中间的小圆</span><br><span class="line">   context.save();</span><br><span class="line">   // 新建一个路径,画笔的位置回到默认的坐标(0,0)的位置</span><br><span class="line">   // 保证了当前的绘制不会影响到之前的绘制</span><br><span class="line">   context.beginPath();</span><br><span class="line">   // 设置填充转盘用的颜色,fill是填充而不是绘制</span><br><span class="line">   context.fillStyle = &apos;#fff&apos;;</span><br><span class="line">   // 绘制一个圆,有六个参数,分别表示:圆心的x坐标,圆心的y坐标,圆的半径,开始绘制的角度,结束的角度,绘制方向(false表示顺时针)</span><br><span class="line">   context.arc(211, 211, 70, startRadian, Math.PI * 2 + startRadian, false);</span><br><span class="line">   // 将设置的颜色填充到圆中,这里不用closePath是因为closePath对fill无效.</span><br><span class="line">   context.fill();</span><br><span class="line">   // 将画布的状态恢复到上一次save()时的状态</span><br><span class="line">   context.restore();</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/22/react实现抽奖大转盘/04.jpg" alt=""><br>4、添加中间的按钮和转盘边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//html</span><br><span class="line">&lt;img className=&quot;wheel-circle&quot; src=&quot;https://wp.touty.io/api/file/5d0c51ff2ab79c000897ecac.image&quot;/&gt;</span><br><span class="line">          &lt;canvas className=&quot;item&quot; id=&quot;wheelcanvas&quot; height=&#123;422&#125; width=&#123;422&#125;/&gt;</span><br><span class="line">          &lt;img onClick=&#123;this.draw.bind(this)&#125; className=&quot;pointer&quot; src=&quot;https://wp.touty.io/api/file/5d0c51c02ab79c000897ecaa.image&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>这样一个静态的大转盘就完成了，下面是让转盘转动起来<br><img src="/2019/06/22/react实现抽奖大转盘/05.jpg" alt=""><br>5、点击抽奖让转盘转起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//点击抽奖让转盘转起来</span><br><span class="line">draw(e) &#123;</span><br><span class="line">  const &#123;canvas, context&#125; = this.state;</span><br><span class="line">  // 只要抽奖没有结束，就不让再次抽奖</span><br><span class="line">  if (!this.state.canBeClick) return;</span><br><span class="line">  this.state.canBeClick = false;</span><br><span class="line">  // 每次点击抽奖，都将初始化角度重置</span><br><span class="line">  this.state.startRadian = 0;</span><br><span class="line">  const distance = this.distanceToStop();</span><br><span class="line">  this.rotatePanel(distance);//调用处理旋转的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>得出最后停留的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">distanceToStop() &#123;</span><br><span class="line">    // middleDegrees为奖品块的中间角度（最终停留都是以中间角度进行计算的）距离初始的startRadian的距离，distance就是当前奖品跑到指针位置要转动的距离。</span><br><span class="line">    let middleDegrees = 0, distance = 0;</span><br><span class="line">    // 映射出每个奖品的middleDegrees</span><br><span class="line">    let awardsToDegreesList = this.state.awards.map((data, index) =&gt; &#123;</span><br><span class="line">      let awardRadian = (Math.PI * 2) / this.state.awards.length;</span><br><span class="line">      return awardRadian * index + (awardRadian * (index + 1) - awardRadian * index) / 2</span><br><span class="line">    &#125;);</span><br><span class="line">    // 随机生成一个索引值，来表示此次抽奖应该中的奖品</span><br><span class="line">    const currentPrizeIndex = Math.floor(Math.random() * this.state.awards.length);</span><br><span class="line">    console.log(&apos;当前奖品应该中的奖品是：&apos; + this.state.awards[currentPrizeIndex].name);</span><br><span class="line">    middleDegrees = awardsToDegreesList[currentPrizeIndex];</span><br><span class="line">    // 因为指针是垂直向上的，相当坐标系的Math.PI/2,所以这里要进行判断来移动角度</span><br><span class="line">    distance = Math.PI * 3 / 2 - middleDegrees;</span><br><span class="line">    distance = distance &gt; 0 ? distance : Math.PI * 2 + distance;</span><br><span class="line">    // 这里额外加上后面的值，是为了让转盘多转动几圈，看上去更像是在抽奖</span><br><span class="line">    return distance + Math.PI * 10;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>让转盘转动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 处理旋转的关键方法</span><br><span class="line">  rotatePanel(distance) &#123;</span><br><span class="line">    // 这里用一个很简单的缓动函数来计算每次绘制需要改变的角度，这样可以达到一个转盘从块到慢的渐变的过程</span><br><span class="line">    let changeRadian = (distance - this.state.startRadian) / 20;</span><br><span class="line">    this.state.startRadian += changeRadian;</span><br><span class="line">    // 当最后的目标距离与startRadian之间的差距低于0.0001时，就默认奖品抽完了，可以继续抽下一个了。</span><br><span class="line">    if (distance - this.state.startRadian &lt;= 0.001) &#123;</span><br><span class="line">      this.state.canBeClick = true;</span><br><span class="line">      return</span><br><span class="line">    &#125; ;</span><br><span class="line">    // 初始角度改变后，需要重新绘制</span><br><span class="line">    this.onLoadPage(this.state.awards);</span><br><span class="line">    // 循环调用rotatePanel函数，使得转盘的绘制连续，造成旋转的视觉效果</span><br><span class="line">    window.requestAnimationFrame(this.rotatePanel.bind(this, distance));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就得到了最终的效果图<br><img src="/2019/06/22/react实现抽奖大转盘/01.gif" alt=""><br>完整代码查看：<a href="https://codepen.io/fuzhen/project/editor/XEyRdE" target="_blank" rel="noopener">codePen</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先看一下实现的效果（这样才有动力）&lt;br&gt;&lt;img src=&quot;/2019/06/22/react实现抽奖大转盘/01.gif&quot; alt=&quot;最后实现效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="react" scheme="https://Lifuzhen.github.io/categories/react/"/>
    
    
      <category term="react" scheme="https://Lifuzhen.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>中国窗棂与css(Chinese Window Lattice And CSS)</title>
    <link href="https://Lifuzhen.github.io/2019/06/19/%E4%B8%AD%E5%9B%BD%E7%AA%97%E6%A3%82%E4%B8%8Ecss-Chinese-Window-Lattice-And-CSS/"/>
    <id>https://Lifuzhen.github.io/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/</id>
    <published>2019-06-19T08:05:01.000Z</published>
    <updated>2019-06-19T09:13:50.529Z</updated>
    
    <content type="html"><![CDATA[<p>本文出处<a href="https://yuanchuan.dev/2019/05/15/window-lattice-and-css.html" target="_blank" rel="noopener">(Chinese Window Lattice And CSS)</a></p><blockquote><p>谁向云端着此亭，檐前树木映窗棂。<br>– 释绍嵩《陪赵知府登桃岭山亭》</p></blockquote><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/01.png" alt="01"></p><a id="more"></a><p>中国传统窗格具有对称美，还有一个非常美丽的正式名称——窗棂<br>作为一个css爱好者，我一直想用css绘制出它们。但这从来都不容易。我想使用SVG可能简单易懂知道我学习了如何使用 -webkit-box-reflect 属性。</p><h1 id="属性-The-property"><a href="#属性-The-property" class="headerlink" title="属性(The property)"></a>属性(The property)</h1><p>不幸的是，-webkit-box-reflect 是非标准的。标准的方式是使用element()函数，该函数已经在firefox中实现。<br>老实说-webkit-box-reflect属性在我看来是非常简洁的，应为它有很好的命名和它不依赖于额外的id像element()。我不知道为什么css工作组不接受它。<br>这是一篇关于css中反射的详细文章，以及Ana Tudor从2016年开始的几个演示。</p><h1 id="趋势-Directions"><a href="#趋势-Directions" class="headerlink" title="趋势(Directions)"></a>趋势(Directions)</h1><p>这个-webkit-box-reflect属性提供四个反射方向：上、下、左和右。如何使用它:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bos&#123;</span><br><span class="line">    -webkit-box-reflect:above|below|left|right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也许因为从一开始它这是一个实验性的属性，所以还没有办法同时给一个元素增加多个反射。</p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/02.png" alt=""></p><p>我认为不同成俗的多次反射比只有4次反射的反射要酷的多！</p><p>它令人兴奋<br>让我们开始使用一个单一的div元素和它在右边的反射。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;△&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    div&#123;</span><br><span class="line">        -webkit-box-reflect:right;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/03.png" alt=""></p><h1 id="如何增加其他的反射？-How-to-add-another-reflection"><a href="#如何增加其他的反射？-How-to-add-another-reflection" class="headerlink" title="如何增加其他的反射？(How to add another reflection?)"></a>如何增加其他的反射？(How to add another reflection?)</h1><p>不久前，ChrisCoyier在本文中介绍了一个技巧，通过应用放置阴影于父节点，将阴影添加到剪裁元素中。<br>我们可以通过添加父节点并对其设置反射来做类似的事情。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;△&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .box &#123;</span><br><span class="line">    -webkit-box-reflect: right;</span><br><span class="line">  &#125;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    -webkit-box-reflect: below;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/04.png" alt=""></p><p>它像一张展开的纸，首先分成两半从左到右，然后从上到下。但是，顺序并不重要。<br>尽管没有得到我们想要的精确的结果，找到一种添加多种反射的方式也令我们兴奋。</p><h1 id="继续深入-Going-deep"><a href="#继续深入-Going-deep" class="headerlink" title="继续深入(Going deep)"></a>继续深入(Going deep)</h1><p>这个总数程指数形式增长，这取决于嵌套div的深度。<br>因此像上面有2个嵌套的div，它们将得到2^2=4个元素（包括所有的反射）。有7个它们将是2^7=128个元素。</p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/05.png" alt=""></p><h1 id="起源-Seed"><a href="#起源-Seed" class="headerlink" title="起源(Seed)"></a>起源(Seed)</h1><p>最深处的div作为起源。因为由反射组成的整个图形将随它而改变。<br>举个例子，旋转-45度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div class=&quot;seed&quot;&gt;△&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  /* ... */</span><br><span class="line">  .seed &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">    transform: rotate(-45deg);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/06.png" alt=""></p><p>或结合一个其他属性及旧方法。这似乎也是另外一种构建Unicode模式不同的方法。</p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/07.png" alt=""></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/08.png" alt=""></p><h1 id="中国窗棂-Chinese-Window-Lattice"><a href="#中国窗棂-Chinese-Window-Lattice" class="headerlink" title="中国窗棂(Chinese Window Lattice)"></a>中国窗棂(Chinese Window Lattice)</h1><p>因此，使用-weblit-box-reflect属性和上述描述的技术，我们可以使用很少的代码在css中画出这些对称的窗棂。<br>我想以本文的开始图片为例，让我们看看如何一步一步的画出它们。</p><h2 id="1、元素的起源-The-seed-element"><a href="#1、元素的起源-The-seed-element" class="headerlink" title="1、元素的起源(The seed element)"></a>1、元素的起源(The seed element)</h2><p>首先，找出最小的元素不能进行分割，这里我们从左上角的部分作为起点。</p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/09.png" alt=""></p><p>然后用 background linear-gradient 绘制这些线。为简单起见，使用空选择器作为种子元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">  div:empty &#123;</span><br><span class="line">    width: 72px; height: 72px;</span><br><span class="line">    --g: linear-gradient(#000, #000);</span><br><span class="line">    --gs: linear-gradient(-45deg,</span><br><span class="line">      transparent calc(50% - 1px), #000 calc(50% - 1px),</span><br><span class="line">      #000 calc(50% + 1px), transparent calc(50% + 1px)</span><br><span class="line">    );</span><br><span class="line">    background:</span><br><span class="line">      var(--g) 0 0 / 100% 2px,       var(--g) 100% 0 / 2px 48px,</span><br><span class="line">      var(--g) 100% 48px / 24px 2px, var(--g) 48px 100% / 2px 24px,</span><br><span class="line">      var(--g) 0 100% / 48px 2px,    var(--g) 0 0 / 2px 100%,</span><br><span class="line">      var(--g) 0 46px / 24px 2px,    var(--g) 24px 100% / 2px 26px,</span><br><span class="line">      var(--g) 100% 24px / 26px 2px, var(--g) 46px 0 / 2px 24px,</span><br><span class="line">      var(--gs) 50% 50% / 24px 24px, var(--gs) 0 0 / 40px 40px;</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2-添加反射-Add-reflection"><a href="#2-添加反射-Add-reflection" class="headerlink" title="2. 添加反射(Add reflection)"></a>2. 添加反射(Add reflection)</h2><p>反射从种子元素本身开始。我们选择“右边”作为初始方向，并使用自定义属性使其更直观。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;--reflect: right -3px&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  div &#123;</span><br><span class="line">     width: 72px;  height: 72px;</span><br><span class="line">    -webkit-box-reflect: var(--reflect);</span><br><span class="line">  &#125;</span><br><span class="line">  div:empty &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/10.png" alt=""></p><h2 id="3-继续展开-Continue-unfolding"><a href="#3-继续展开-Continue-unfolding" class="headerlink" title="3. 继续展开(Continue unfolding)"></a>3. 继续展开(Continue unfolding)</h2><p>所以我们要添加父节点来进行更多的反射。如果你把它看成是展开一张纸，那就真的有助于理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;--reflect: below -2px&quot;&gt;</span><br><span class="line">  &lt;div style=&quot;--reflect: right -3px&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/11.png" alt=""></p><h1 id="再加一个-Add-another-one"><a href="#再加一个-Add-another-one" class="headerlink" title="再加一个(Add another one.)"></a>再加一个(Add another one.)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;--reflect: below calc(200% - 6px)&quot;&gt;</span><br><span class="line">  &lt;div style=&quot;--reflect: below -2px&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;--reflect: right -3px&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/12.png" alt=""></p><p>重复这个过程直到我们得到想要的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;--reflect: right calc(600% - 14px)&quot;&gt;</span><br><span class="line">  &lt;div style=&quot;--reflect: right calc(200% - 6px)&quot;&gt;</span><br><span class="line">    &lt;div style=&quot;--reflect: below calc(400% - 10px)&quot;&gt;</span><br><span class="line">      &lt;div style=&quot;--reflect: below calc(200% - 6px)&quot;&gt;</span><br><span class="line">        &lt;div style=&quot;--reflect: below -2px&quot;&gt;</span><br><span class="line">          &lt;div style=&quot;--reflect: right -2px&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/13.png" alt=""></p><p>That’s it.<br>您可以在<a href="https://codepen.io/fuzhen/pen/RzGzEM" target="_blank" rel="noopener">CodePen</a>上看到结果和完整的源代码。但它只在Chrome和Safari中有效。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>使用-webkit box reflect属性的解决方案在某种程度上很漂亮。我真希望它能被接受为一个标准，甚至能在各个方面做反射。这样就有可能在CSS中做剪纸（中国剪纸艺术）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文出处&lt;a href=&quot;https://yuanchuan.dev/2019/05/15/window-lattice-and-css.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;(Chinese Window Lattice And CSS)&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;谁向云端着此亭，檐前树木映窗棂。&lt;br&gt;– 释绍嵩《陪赵知府登桃岭山亭》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/2019/06/19/中国窗棂与css-Chinese-Window-Lattice-And-CSS/01.png&quot; alt=&quot;01&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="https://Lifuzhen.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://Lifuzhen.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题深入解析-01</title>
    <link href="https://Lifuzhen.github.io/2019/06/04/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90-01/"/>
    <id>https://Lifuzhen.github.io/2019/06/04/前端面试题深入解析-01/</id>
    <published>2019-06-04T10:20:22.000Z</published>
    <updated>2019-06-04T10:23:35.355Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周面试题一览:</p></blockquote><ul><li>节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数</li><li>说一说你对JS执行上下文栈和作用域链的理解？</li><li>什么是BFC？BFC的布局规则是什么？如何创建BFC？</li><li>let、const、var 的区别有哪些？</li><li>深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？</li></ul><a id="more"></a><h1 id="节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。"><a href="#节流-throttle-函数的作用是什么？有哪些应用场景，请实现一个节流函数。" class="headerlink" title="节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。"></a>节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数。</h1><h2 id="节流函数的作用"><a href="#节流函数的作用" class="headerlink" title="节流函数的作用"></a>节流函数的作用</h2><p>节流函数的作用是规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只有一次生效！</p><p>举例说明：小明的妈妈和小明约定好，如果小明在周考中取得满分，那么当月可以带他去游乐场玩，但是一个月最多只能去一次。</p><p>这其实就是一个节流的例子，在一个月的时间内，这个时间周期内，小明取得多次满分，去游乐场最多只能触发一次。</p><h2 id="节流应用场景"><a href="#节流应用场景" class="headerlink" title="节流应用场景"></a>节流应用场景</h2><p>1、按钮点击事件<br>2、拖拽事件<br>3、onScroll<br>4、计算鼠标移动的距离（mousemove）</p><h2 id="节流函数实现"><a href="#节流函数实现" class="headerlink" title="节流函数实现"></a>节流函数实现</h2><blockquote><p>利用时间戳实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">    var lastTime = 0;</span><br><span class="line">    function throttled() &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        var nowTime = Date.now();</span><br><span class="line">        if (nowTime &gt; lastTime + delay) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            lastTime = nowTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//防抖函数最终返回的是一个函数</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>利用定时器实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, delay) &#123;</span><br><span class="line">    var timeout = null;</span><br><span class="line">    function throttled() &#123;</span><br><span class="line">        var context = this;</span><br><span class="line">        var args = arguments;</span><br><span class="line">        if (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout(()=&gt;&#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null</span><br><span class="line">                &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>时间戳和定时器的方式都没有考虑最后一次执行的问题，比如有个按钮点击事件，设置的间隔时间是1S，在第0.5S，1.8S，2.2S点击，那么只有0.5S和1.8S的两次点击能够触发函数执行，而最后一次的2.2S会被忽略。</p><blockquote><p>组合实现，允许设置第一次或者最后一次是否触发函数执行</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function throttle(func, wait, options) &#123;</span><br><span class="line">    var timeout, context, args, result;</span><br><span class="line">    var previous = 0;</span><br><span class="line">    if (!options) options = &#123;&#125;;</span><br><span class="line">    var later = function () &#123;</span><br><span class="line">        previous = options.leading === false ? 0 : Date.now() || new Date().getTime();</span><br><span class="line">        timeout = null;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        if (!timeout) context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var throttled = function () &#123;</span><br><span class="line">        var now = Date.now() || new Date().getTime();</span><br><span class="line">        if (!previous &amp;&amp; options.leading === false) previous = now;</span><br><span class="line">        var remaining = wait - (now - previous);</span><br><span class="line">        context = this;</span><br><span class="line">        args = arguments;</span><br><span class="line">        if (remaining &lt;= 0 || remaining &gt; wait) &#123;</span><br><span class="line">            if (timeout) &#123;</span><br><span class="line">                clearTimeout(timeout);</span><br><span class="line">                timeout = null;</span><br><span class="line">            &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context, args);</span><br><span class="line">            if (!timeout) context = args = null;</span><br><span class="line">        &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123;</span><br><span class="line">// 判断是否设置了定时器和 trailing</span><br><span class="line">            timeout = setTimeout(later, remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">    throttled.cancel = function () &#123;</span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">            previous = 0;</span><br><span class="line">            timeout = context = args = null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return throttled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用简单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btn . onclick = throttle(handle ,1000,&#123;leading:true ,trailing:true&#125;);</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="说一说你对JS执行上下文栈和作用域链的理解？"><a href="#说一说你对JS执行上下文栈和作用域链的理解？" class="headerlink" title="说一说你对JS执行上下文栈和作用域链的理解？"></a>说一说你对JS执行上下文栈和作用域链的理解？</h1><p>在开始说明JS上下文栈和作用域之前，我们先说明下JS上下文以及作用域的概念。</p><h2 id="JS执行上下文"><a href="#JS执行上下文" class="headerlink" title="JS执行上下文"></a>JS执行上下文</h2><p>执行上下文就是当前 JavaScript 代码被解析和执行时所在环境的抽象概念， JavaScript 中运行任何的代码都是在执行上下文中运行。</p><blockquote><p>执行上下文类型分为：</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval函数执行上下文(不被推荐)</li></ul></blockquote><p>执行上下文创建过程中，需要做以下几件事:<br>    1、创建变量对象：首先初始化函数的参数arguments，提升函数声明和变量声明。<br>    2、创建作用域链（Scope Chain）：在执行期上下文的创建阶段，作用域链是在变量对象之后创建的。<br>    3、确定this的值，即 ResolveThisBinding</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域负责收集和维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。—— 摘录自《你不知道的JavaScript》(上卷)</p><p>作用域有两种工作模型：词法作用域和动态作用域，JS采用的是词法作用域工作模型，词法作用域意味着作用域是由书写代码时变量和函数声明的位置决定的。( with 和 eval 能够修改词法作用域，但是不推荐使用，对此不做特别说明)</p><blockquote><p>作用域分为：</p><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul></blockquote><h2 id="JS执行上下文栈-后面简称执行栈"><a href="#JS执行上下文栈-后面简称执行栈" class="headerlink" title="JS执行上下文栈(后面简称执行栈)"></a>JS执行上下文栈(后面简称执行栈)</h2><p>执行栈，也叫做调用栈，具有 LIFO (后进先出) 结构，用于存储在代码执行期间创建的所有执行上下文。</p><blockquote><p>规则如下：</p><ul><li>首次运行JavaScript代码的时候,会创建一个全局执行的上下文并Push到当前的执行栈中，每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push当前执行栈的栈顶。</li><li>当栈顶的函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文的控制权将移动到当前执行栈的下一个执行上下文。</li></ul></blockquote><p>以一段代码具体说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fun3() &#123;</span><br><span class="line">    console.log(&apos;fun3&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function fun2() &#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line">function fun1() &#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line">fun1();</span><br></pre></td></tr></table></figure></p><p>GlobalExecutionContext (即全局执行上下文)首先入栈，过程如下：<br><img src="/2019/06/04/前端面试题深入解析-01/01.webp" alt="01"></p><p>伪代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//全局执行上下文首先入栈</span><br><span class="line">ECStack.push (     globalContext );</span><br><span class="line">//执行fun1();</span><br><span class="line">ECStack. push (&lt;     fun1 &gt;     functionContext     ); </span><br><span class="line">//fun1中又调用了fun2;</span><br><span class="line">ECStack . push (&lt;fun2&gt;functionContext );</span><br><span class="line">//fun2中又调用了fun3;</span><br><span class="line">ECStack . push (&lt;fun3&gt;functionContext ); </span><br><span class="line">//fun3执行完毕</span><br><span class="line">ECStack . pop ();</span><br><span class="line">//fun2执行完毕</span><br><span class="line">ECStack . pop ();</span><br><span class="line">//fun1执行完毕</span><br><span class="line">ECStack . pop (); </span><br><span class="line">//javascript继续顺序执行下面的代码，但ECStack底部始终有一个 全局上下文（globalContext）;</span><br></pre></td></tr></table></figure></p><h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链就是从当前作用域开始一层一层向上寻找某个变量，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是作用域链。</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">function fn1() &#123;</span><br><span class="line">    var b = 20;</span><br><span class="line">    console.log(fn2)</span><br><span class="line">    function fn2() &#123;</span><br><span class="line">        a = 20</span><br><span class="line">    &#125;</span><br><span class="line">    return fn2;</span><br><span class="line">&#125;</span><br><span class="line">fn1()();</span><br></pre></td></tr></table></figure></p><p>fn2作用域链 = [fn2作用域, fn1作用域，全局作用域]<br><img src="/2019/06/04/前端面试题深入解析-01/02.webp" alt="02"></p><h1 id="什么是BFC？BFC的布局规则是什么？如何创建BFC？"><a href="#什么是BFC？BFC的布局规则是什么？如何创建BFC？" class="headerlink" title="什么是BFC？BFC的布局规则是什么？如何创建BFC？"></a>什么是BFC？BFC的布局规则是什么？如何创建BFC？</h1><h2 id="什么是BFC？"><a href="#什么是BFC？" class="headerlink" title="什么是BFC？"></a>什么是BFC？</h2><p>BFC 是 Block Formatting Context 的缩写，即块格式化上下文。我们来看一下CSS2.1规范中对 BFC 的说明。</p><blockquote><p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with ‘overflow’ other than ‘visible’ (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.<br>  浮动、绝对定位的元素、非块级盒子的块容器（如inline-blocks、table-cells 和 table-captions），以及 overflow的值不为 visible（该值已传播到视区时除外）为其内容建立新的块格式上下文。</p></blockquote><p>因此，如果想要深入的理解BFC，我们需要了解以下两个概念：</p><blockquote><p>1.Box<br>  2.Formatting Context</p></blockquote><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><p>Box 是 CSS 布局的对象和基本单位，页面是由若干个Box组成的。</p><p>元素的类型 和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的 Formatting Context。</p><h2 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h2><p>Formatting Context 是页面的一块渲染区域，并且有一套渲染规则，决定了其子元素将如何定位，以及和其它元素的关系和相互作用。</p><p>Formatting Context 有 BFC (Block formatting context)，IFC (Inline formatting context)，FFC (Flex formatting context) 和 GFC (Grid formatting context)。FFC 和 GFC 为 CC3 中新增。</p><h2 id="BFC布局规则"><a href="#BFC布局规则" class="headerlink" title="BFC布局规则"></a>BFC布局规则</h2><ul><li>BFC内，盒子依次垂直排列。</li><li>BFC内，两个盒子的垂直距离由 margin 属性决定。属于同一个BFC的两个相邻Box的margin会发生重叠【符合合并原则的margin合并后是使用大的margin】</li><li>BFC内，每个盒子的左外边缘接触内部盒子的左边缘（对于从右到左的格式，右边缘接触）。即使在存在浮动的情况下也是如此。除非创建新的BFC。</li><li>BFC的区域不会与float box重叠。</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><h2 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h2><p>根元素</p><ul><li>浮动元素（float 属性不为 none）</li><li>position 为 absolute 或 relative</li><li>overflow 不为 visible 的块元素</li><li>display 为 inline-block, table-cell, table-caption</li></ul><h2 id="BFC的应用"><a href="#BFC的应用" class="headerlink" title="BFC的应用"></a>BFC的应用</h2><p>1.防止 margin 重叠<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    . a&#123;</span><br><span class="line">    height:100px;</span><br><span class="line">    width:100px;</span><br><span class="line">    margin:50px;</span><br><span class="line">    background:pink;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt; body &gt;</span><br><span class="line">&lt;div className=&quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div className=&quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt; /body&gt;</span><br></pre></td></tr></table></figure></p><p>两个div直接的 margin 是50px，发生了 margin 的重叠。<br><img src="/2019/06/04/前端面试题深入解析-01/03.jpg" alt="03"></p><blockquote><p>根据BFC规则，同一个BFC内的两个两个相邻Box的 margin 会发生重叠，因此我们可以在div外面再嵌套一层容器，并且触发该容器生成一个 BFC，这样 &lt;divclass=”a”&gt; 就会属于两个 BFC，自然也就不会再发生 margin 重叠</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    . a&#123;</span><br><span class="line">    height:100px;</span><br><span class="line">    width:100px;</span><br><span class="line">    margin:50px;</span><br><span class="line">    background:pink;</span><br><span class="line">    &#125;</span><br><span class="line">    .container&#123;</span><br><span class="line">    overflow:auto;/*触发生成BFC*/</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt; body &gt;</span><br><span class="line">&lt;div className=&quot;container&quot;&gt;</span><br><span class="line">    &lt; div className = &quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div className=&quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt; /body&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/04/前端面试题深入解析-01/04.png" alt="04"></p><p>2.清除内部浮动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   . a&#123;</span><br><span class="line">   height:100px;</span><br><span class="line">   width:100px;</span><br><span class="line">   margin:5px;</span><br><span class="line">   background:pink;</span><br><span class="line">   float: left;</span><br><span class="line">   &#125;</span><br><span class="line">   .container&#123;</span><br><span class="line">       width: 120px;</span><br><span class="line">       border: 2px solid black;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt; body &gt;</span><br><span class="line">    &lt;div className=&quot;container&quot;&gt;</span><br><span class="line">       &lt; div className = &quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt; /body&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/04/前端面试题深入解析-01/05.jpg" alt="05"></p><blockquote><p>container 的高度没有被撑开，如果我们希望 container 的高度能够包含浮动元素，那么可以创建一个新的 BFC，因为根据 BFC 的规则，计算 BFC 的高度时，浮动元素也参与计算。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   . a&#123;</span><br><span class="line">   height:100px;</span><br><span class="line">   width:100px;</span><br><span class="line">   margin:50px;</span><br><span class="line">   background:pink;</span><br><span class="line">   float: left;</span><br><span class="line">   &#125;</span><br><span class="line">   .container&#123;</span><br><span class="line">       display: inline-block;/*触发生成BFC*/</span><br><span class="line">       border: 2px solid black;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="/2019/06/04/前端面试题深入解析-01/06.jpg" alt="06"></p><p>3.自适应多栏布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    body&#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    &#125;</span><br><span class="line">   . a&#123;</span><br><span class="line">   height:150px;</span><br><span class="line">   width:100px;</span><br><span class="line">   background:pink;</span><br><span class="line">   float: left;</span><br><span class="line">   &#125;</span><br><span class="line">   .b&#123;</span><br><span class="line">       height: 200px;</span><br><span class="line">       background:blue;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div className = &quot;a&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div className = &quot;b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt; /body&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/04/前端面试题深入解析-01/07.jpg" alt="07"></p><blockquote><p>根据规则，BFC的区域不会与float box重叠。因此，可以触发生成一个新的BFC，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">   .b&#123;</span><br><span class="line">       height: 200px;</span><br><span class="line">       overflow: hidden;/*触发生成BFC*/</span><br><span class="line">       background:blue;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p><img src="/2019/06/04/前端面试题深入解析-01/08.jpg" alt="08"></p><h1 id="4-let、const、var-的区别有哪些？"><a href="#4-let、const、var-的区别有哪些？" class="headerlink" title="4. let、const、var 的区别有哪些？"></a>4. let、const、var 的区别有哪些？</h1><table><thead><tr><th style="text-align:center">声明方式</th><th style="text-align:center">变量提升</th><th style="text-align:center">暂时性死区</th><th style="text-align:center">重复声明</th><th style="text-align:center">块作用域有效</th><th style="text-align:center">初始值</th><th style="text-align:center">重新赋值</th></tr></thead><tbody><tr><td style="text-align:center">var</td><td style="text-align:center">会</td><td style="text-align:center">不存在</td><td style="text-align:center">允许</td><td style="text-align:center">不是</td><td style="text-align:center">非必须</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">let</td><td style="text-align:center">不会</td><td style="text-align:center">存在</td><td style="text-align:center">不允许</td><td style="text-align:center">是</td><td style="text-align:center">非必须</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">const</td><td style="text-align:center">不会</td><td style="text-align:center">存在</td><td style="text-align:center">不允许</td><td style="text-align:center">是</td><td style="text-align:center">必须</td><td style="text-align:center">不允许</td></tr></tbody></table><h2 id="1-let-const-定义的变量不会出现变量提升，而-var-定义的变量会提升。"><a href="#1-let-const-定义的变量不会出现变量提升，而-var-定义的变量会提升。" class="headerlink" title="1.let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。"></a>1.let/const 定义的变量不会出现变量提升，而 var 定义的变量会提升。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a =10;</span><br><span class="line">var a;//正常</span><br><span class="line"></span><br><span class="line">a =10;</span><br><span class="line">let a; //ReferenceError</span><br></pre></td></tr></table></figure><h2 id="2-相同作用域中，let-和-const-不允许重复声明，var-允许重复声明。"><a href="#2-相同作用域中，let-和-const-不允许重复声明，var-允许重复声明。" class="headerlink" title="2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。"></a>2.相同作用域中，let 和 const 不允许重复声明，var 允许重复声明。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a =10;</span><br><span class="line">var a= 20;</span><br><span class="line">//抛出异常:SyntaxError:Identifier &apos;a&apos; has already been declared</span><br></pre></td></tr></table></figure><h2 id="3-const-声明变量时必须设置初始值"><a href="#3-const-声明变量时必须设置初始值" class="headerlink" title="3.const 声明变量时必须设置初始值"></a>3.const 声明变量时必须设置初始值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a;//SyntaxError: Missing initializer in const declaration</span><br></pre></td></tr></table></figure><h2 id="4-const-声明一个只读的常量，这个常量不可改变。"><a href="#4-const-声明一个只读的常量，这个常量不可改变。" class="headerlink" title="4.const 声明一个只读的常量，这个常量不可改变。"></a>4.const 声明一个只读的常量，这个常量不可改变。</h2><p>这里有一个非常重要的点即是：复杂数据类型，存储在栈中的是堆内存的地址，存在栈中的这个地址是不变的，但是存在堆中的值是可以变得。有没有相当常量指针/指针常量~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a = 10;</span><br><span class="line">const b =&#123;</span><br><span class="line">    age: 18,</span><br><span class="line">    star: 500</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一图胜万言，如下图所示，不变的是栈内存中 a 存储的 10，和 b 中存储的 0x0012ff21（瞎编的一个数字）。而 {age: 18, star: 200} 是可变的。思考下如果想希望一个对象是不可变的，应该用什么方法？<br><img src="/2019/06/04/前端面试题深入解析-01/09.webp" alt="09"></p><h2 id="5-let-const-声明的变量仅在块级作用域中有效。而-var-声明的变量在块级作用域外仍能访问到。"><a href="#5-let-const-声明的变量仅在块级作用域中有效。而-var-声明的变量在块级作用域外仍能访问到。" class="headerlink" title="5.let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。"></a>5.let/const 声明的变量仅在块级作用域中有效。而 var 声明的变量在块级作用域外仍能访问到。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">let a = 10;</span><br><span class="line">const b =20;</span><br><span class="line">var c = 30;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a);//ReferenceError</span><br><span class="line">console.log(b);//ReferenceError</span><br><span class="line">console.log(c);//30</span><br></pre></td></tr></table></figure><p>在 let/const 之前，最早学习JS的时候，也曾被下面这个问题困扰：<br>期望： a【0】()输出0,a【1】()输出1,a【2】()输出2,…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for(var i =0; i&lt;10;i++)&#123;</span><br><span class="line">    a[i]= function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6]();//10</span><br></pre></td></tr></table></figure></p><p><img src="/2019/06/04/前端面试题深入解析-01/10.webp" alt="10"></p><p>虽然后来知道了为什么，但是想要得到自己需要的结果，还得整个闭包，我…我做错了什么，要这么对我…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">   for(var i =0; i&lt;10;i++)&#123;</span><br><span class="line">       a[i]= (function(j)&#123;</span><br><span class="line">        return function()&#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;   </span><br><span class="line">      &#125;)(i);</span><br><span class="line">   &#125;</span><br><span class="line">   a[6]();//10</span><br></pre></td></tr></table></figure><p>有了 let 之后，终于不要这么麻烦了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for(let i =0; i&lt;10;i++)&#123;</span><br><span class="line">    a[i]= function()&#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6]();//10</span><br></pre></td></tr></table></figure></p><p>美滋滋，有没有~</p><p>美是美了，但是总得问自己为什么吧~</p><p>vari 为什么输出的是 10，这是因为 i 在全局范围内都是有效的，相当于只有一个变量 i，等执行到 a【6】() 的时候，这个 i 的值是什么？请大声说出来。</p><p>再看 let , 我们说 let 声明的变量仅在块级作用域内有效，变量i是let声明的，当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量。有兴趣的小伙伴可以查看 babel 编译后的代码。</p><h2 id="6、顶层作用域中-var-声明的变量挂在window上-浏览器环境"><a href="#6、顶层作用域中-var-声明的变量挂在window上-浏览器环境" class="headerlink" title="6、顶层作用域中 var 声明的变量挂在window上(浏览器环境)"></a>6、顶层作用域中 var 声明的变量挂在window上(浏览器环境)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 10;</span><br><span class="line">consle.log(window.a);//10</span><br></pre></td></tr></table></figure><h2 id="7、let-const有暂时性死区的问题，即let-const-声明的变量，在定义之前都是不可用的。如果使用会抛出错误。"><a href="#7、let-const有暂时性死区的问题，即let-const-声明的变量，在定义之前都是不可用的。如果使用会抛出错误。" class="headerlink" title="7、let/const有暂时性死区的问题，即let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。"></a>7、let/const有暂时性死区的问题，即let/const 声明的变量，在定义之前都是不可用的。如果使用会抛出错误。</h2><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a= 10;</span><br><span class="line">if(true)&#123;</span><br><span class="line">    a = 20;//ReferenceError</span><br><span class="line">    let a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码块内，使用 let/const 命令声明变量之前，该变量都是不可用的，也就意味着 typeof 不再是一个百分百安全的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof b);//undefined</span><br><span class="line">console.log(a);ReferenceError</span><br><span class="line">let a = 10;</span><br></pre></td></tr></table></figure><h1 id="5、深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？"><a href="#5、深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？" class="headerlink" title="5、深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？"></a>5、深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？</h1><p>深拷贝和浅拷贝是针对复杂数据类型来说的。</p><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote><p>深拷贝复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。 深拷贝后的对象与原来的对象是完全隔离的，互不影响，对一个对象的修改并不会影响另一个对象。</p></blockquote><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><blockquote><p>浅拷贝是会将对象的每个属性进行依次复制，但是当对象的属性值是引用类型时，实质复制的是其引用，当引用指向的值改变时也会跟着变化。</p></blockquote><p>可以使用 for in、 Object.assign、 扩展运算符 … 、 Array.prototype.slice()、 Array.prototype.concat() 等，例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;Yvette&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    hobbies: [&apos;reading&apos;, &apos;photography&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = Object.assign(&#123;&#125;, obj);</span><br><span class="line">let obj3 = &#123;...obj&#125;;</span><br><span class="line">obj.name = &apos;Jack&apos;;</span><br><span class="line">obj.hobbies.push(&apos;coding&apos;);</span><br><span class="line">console.log(obj);//&#123; name: &apos;Jack&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;</span><br><span class="line">console.log(obj2);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;</span><br><span class="line">console.log(obj3);//&#123; name: &apos;Yvette&apos;, age: 18,hobbies: [ &apos;reading&apos;, &apos;photography&apos;, &apos;coding&apos; ] &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出浅拷贝只最第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向的是同一块内存地址。来看一下使用 forin 实现浅拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;Yvette&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    hobbies: [&apos;reading&apos;, &apos;photography&apos;]</span><br><span class="line">&#125;</span><br><span class="line">let newObj = &#123;&#125;;</span><br><span class="line">for (let key in obj)&#123;</span><br><span class="line">    newObj[key] = obj[key];//这一步不需要多说吧，复杂数据类型栈中存的是对应的地址，因此赋值操作，相当于两个属性值指向同一个内存空间</span><br><span class="line">&#125;</span><br><span class="line">console.log(newObj);//&#123; name: &apos;Yvette&apos;, age: 18, hobbies: [ &apos;reading&apos;, &apos;photography&apos; ] &#125;</span><br><span class="line">obj.age = 20;</span><br><span class="line">obj.hobbies.pop();</span><br><span class="line">console.log(newObj);//&#123; name: &apos;Yvette&apos;, age: 18, hobbies: [ &apos;reading&apos; ] &#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><blockquote><p>1.深拷贝最简单的实现是: JSON.parse(JSON.stringify(obj))</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;Yvette&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    hobbies: [&apos;reading&apos;, &apos;photography&apos;]</span><br><span class="line">&#125;;</span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj));//newObj和obj互不影响</span><br><span class="line">obj.hobbies.push(&apos;coding&apos;);</span><br><span class="line">console.log(newObj);//&#123; name: &apos;Yvette&apos;, age: 18, hobbies: [ &apos;reading&apos;, &apos;photography&apos; ] &#125;</span><br></pre></td></tr></table></figure><p>JSON.parse(JSON.stringify(obj)) 是最简单的实现方式，但是有一点缺陷：</p><p>1.对象的属性值是函数时，无法拷贝。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    name: &apos;Yvette&apos;,</span><br><span class="line">    age: 18,</span><br><span class="line">    hobbies: [&apos;reading&apos;, &apos;photography&apos;],</span><br><span class="line">    sayHi: function () &#123;</span><br><span class="line">        console.log(sayHi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);//&#123; name: &apos;Yvette&apos;, age: 18, hobbies: [ &apos;reading&apos;, &apos;photography&apos; ] &#125;</span><br></pre></td></tr></table></figure><p>2.原型链上的属性无法获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Super() &#123;&#125;</span><br><span class="line">Super.prototype.location = &apos;NanJing&apos;;</span><br><span class="line">function Child(name, age, hobbies) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Child.prototype = new Super();</span><br><span class="line">let obj = new Child(&apos;Yvette&apos;, 18);</span><br><span class="line">console.log(obj.location);</span><br><span class="line">//NanJing</span><br><span class="line">let newObj = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(newObj);//&#123; name: &apos;Yvette&apos;, age: 18&#125;</span><br><span class="line">console.log(newObj.location);//undefined;原型链上的属性无法获取</span><br></pre></td></tr></table></figure><p>3.不能正确的处理 Date 类型的数据</p><p>4.不能处理 RegExp</p><p>5.会忽略 symbol</p><p>6.会忽略 undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    time: new Date(),</span><br><span class="line">    reg: /\d&#123;3&#125;/,</span><br><span class="line">    sym: Symbol(10),</span><br><span class="line">    name: undefined</span><br><span class="line">&#125;;</span><br><span class="line">let obj2 = JSON.parse(JSON.stringify(obj));</span><br><span class="line">console.log(obj2);//&#123; time: &apos;2019-06-02T08:16:44.625Z&apos;, reg: &#123;&#125; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.实现一个 deepClone 函数</p></blockquote><pre><code>1、如果是基本数据类型，直接返回2、如果是 RegExp 或者 Date 类型，返回对应类型3、如果是复杂数据类型，递归拷贝。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(obj) &#123;//递归拷贝</span><br><span class="line">    if (obj instanceof RegExp) returnnewRegExp(obj);</span><br><span class="line">    if (obj instanceof Date) return new Date(obj);</span><br><span class="line">    if (obj === null || typeof obj !== &apos;object&apos;) &#123;//如果不是复杂数据类型，直接返回</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 如果obj是数组，那么 obj.constructor 是 [Function: Array]</span><br><span class="line">     * 如果obj是对象，那么 obj.constructor 是 [Function: Object]</span><br><span class="line">     */</span><br><span class="line">    let t = new obj.constructor();</span><br><span class="line">    for (let key in obj) &#123;//如果 obj[key] 是复杂数据类型，递归</span><br><span class="line">        if (obj.hasOwnProperty(key))&#123;//是否是自身的属性</span><br><span class="line">            t[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周面试题一览:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;节流(throttle)函数的作用是什么？有哪些应用场景，请实现一个节流函数&lt;/li&gt;
&lt;li&gt;说一说你对JS执行上下文栈和作用域链的理解？&lt;/li&gt;
&lt;li&gt;什么是BFC？BFC的布局规则是什么？如何创建BFC？&lt;/li&gt;
&lt;li&gt;let、const、var 的区别有哪些？&lt;/li&gt;
&lt;li&gt;深拷贝和浅拷贝的区别是什么？如何实现一个深拷贝？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端面试题" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于移动端适配，你必须要知道的</title>
    <link href="https://Lifuzhen.github.io/2019/06/03/%E5%85%B3%E4%BA%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%EF%BC%8C%E4%BD%A0%E5%BF%85%E9%A1%BB%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84/"/>
    <id>https://Lifuzhen.github.io/2019/06/03/关于移动端适配，你必须要知道的/</id>
    <published>2019-06-03T10:42:28.000Z</published>
    <updated>2019-06-03T10:44:58.255Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;mid=2247483747&amp;idx=1&amp;sn=90cb7d69ca1b996809dd02a32078cd5d&amp;chksm=ebf9f6b9dc8e7faf867e5ec22339e65efdb0002bc7d9f1867a53edb8c5318a94a8d13737a269&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=47a58d19edbb3f926e528c56a70e589ae4e1cf407b6c9c8b6d9a12d873ac30d5305221e22dec0e82151432be214eab8486154ff64e20d56ad7cdcb461faaebe75242d05895b2e35d5cc7ed48027ebeee&amp;ascene=1&amp;uin=Mjk1MDEwMzIwNw%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=en&amp;pass_ticket=Kg%2BuI6pXTVeQSCOOiejokLvubZ6zl%2FsBhrz7K%2B4cm%2B%2FtjWT1MFYKGhT2efwdnKdG" target="_blank" rel="noopener">code秘密花园</a>.</p><p>本文有点长，耐心阅读！<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/view.jpg" alt="view"><br><a id="more"></a><br><strong>导读</strong></p><p>移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题：</p><ul><li>1px问题</li><li>UI图完美适配方案</li><li>iPhoneX适配方案</li><li>横屏适配</li><li>高清图片模糊问题</li><li>…<br>上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、PPI、DPI、DP、DIP、DPR、视口等等，你真的能分清这些概念的意义吗？</li></ul><p>本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。</p><h1 id="一、英寸"><a href="#一、英寸" class="headerlink" title="一、英寸"></a>一、英寸</h1><p>一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸。</p><p>需要注意，上面尺寸都是屏幕对角线的长度：</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/01.webp" alt="01"></p><p>英寸（inch，缩写为in）在荷兰语中的本意是大拇指，一英寸就是普通人拇指的宽度。<br>英寸与厘米的换算：1英寸 = 2.54厘米</p><h1 id="二、分辨率"><a href="#二、分辨率" class="headerlink" title="二、分辨率"></a>二、分辨率</h1><h2 id="2-1-像素"><a href="#2-1-像素" class="headerlink" title="2.1 像素"></a>2.1 像素</h2><p>像素即一个小方块，它具有特定的位置和颜色。<br>图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。<br>像素可以作为图片或电子屏幕的最小组成单位。</p><p>下面我们使用ps打开一张图片：<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/02.jpg" alt="02"></p><p>将这个图片放大即可看到这些像素点<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/03.jpg" alt="03"></p><p>通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率</p><h2 id="2-2-屏幕分辨率"><a href="#2-2-屏幕分辨率" class="headerlink" title="2.2 屏幕分辨率"></a>2.2 屏幕分辨率</h2><p>屏幕分辨率指一个屏幕具体由多少个像素点组成。<br>下面是apple官网上对手机分辨率的描述：<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/04.webp" alt="04"><br>iPhone XS Max和iPhone SE的分辨率分别为2688 X 1242和1136 X 640.这表示手机分别在垂直和水平上所具有的像素点数。</p><p>当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。</p><h2 id="2-3-图像分辨率"><a href="#2-3-图像分辨率" class="headerlink" title="2.3 图像分辨率"></a>2.3 图像分辨率</h2><p>我们通常所说的图片分辨率其实是指图片含有的像素数，比如一张图片的分辨率是800 X 400 。这表示图片分别在垂直和水平上所具有的像素点数为800和400.</p><p>同一尺寸的图片，分辨率越高，图片越清晰。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/05.webp" alt="05"></p><h2 id="2-4-PPI"><a href="#2-4-PPI" class="headerlink" title="2.4 PPI"></a>2.4 PPI</h2><p>PPI(Pixel Per Inch)：每英寸包含的像素数。<br>PPI可以用于描述屏幕的清晰度以及一张图片的质量。<br>使用PPI描述图片时，PPI越高图片质量越高。使用PPI描述屏幕时，PPI越高，屏幕越清晰。<br>在上面描述手机分辨率的图片中，我们可以看到： iPhone XSMax 和 iPhone SE的 PPI分别为458和326，这足以证明前者的屏幕更清晰。<br>由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算 PPI:<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/PPI.jpg" alt="PPI"></p><p>iPhone6的 PPI为 √（1334^2+750^2）/4.7=325.6，那它每英寸约含有 326个物理像素点。</p><h2 id="2-5-DPI"><a href="#2-5-DPI" class="headerlink" title="2.5 DPI"></a>2.5 DPI</h2><p>DPI（Dot Per Inch）:及每英寸包括的点数。<br>这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。<br>平时你可能会看到使用DPI来描述图片和屏幕，这时的DPI应该和PPI是等价的，DPI最常用的是用户描述打印机，表示打印机每英寸可以打印的点数。</p><p>一张图片在屏幕上显示，它的像素点数是规则排列的，每个像素点都有固定的位置和颜色。</p><p>当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是DPI所描述的：打印点的密度。<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/06.webp" alt="06"></p><p>在上面的图像中我们可以清晰的看到，打印机时如何使用墨点来打印一张图像。<br>所以打印机的DPI越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。</p><h1 id="三、设备独立像素"><a href="#三、设备独立像素" class="headerlink" title="三、设备独立像素"></a>三、设备独立像素</h1><p>实际上，上面我们所描述的像素都是物理像素，即设备上真实的物理单元。<br>下面我们来看看设备独立像素究竟是如何产生的：<br>智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是320X480，我们可以在上面浏览正常的文字、图片等等。<br>但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是640X940，正好是白色手机的两倍。<br>理论上来讲，在白色手机上相同文字大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/07.webp" alt="07"><br>然而事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在 iPhone4的发布会上首次提出了 RetinaDisplay(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/08.webp" alt="08"></p><p>在 iPhone4使用的视网膜屏幕中，把 2x2个像素当 1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/09.webp" alt="09"></p><p>如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为 300个像素，那么在一条水平线上，白色手机会用 300个物理像素去渲染它，而黑色手机实际上会用 600个物理像素去渲染它。</p><p>我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素( DeviceIndependentPixels)简称 DIP或 DP。上面我们说，列表的宽度为 300个像素，实际上我们可以说：列表的宽度为 300个设备独立像素。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/10.webp" alt="10"></p><p>打开 chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如 iPhone X显示的尺寸是 375x812，实际 iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/11.webp" alt="11"></p><h2 id="3-1-设备像素比"><a href="#3-1-设备像素比" class="headerlink" title="3.1 设备像素比"></a>3.1 设备像素比</h2><p>设备像素比 device pixel ratio简称 dpr，即物理像素和设备独立像素的比值。<br>在 web中，浏览器为我们提供了 window.devicePixelRatio来帮助我们获取 dpr。<br>在 css中，可以使用媒体查询 min-device-pixel-ratio，区分 dpr：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@media(-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)&#123; &#125;</span><br></pre></td></tr></table></figure></p><p>在 ReactNative中，我们也可以使用 PixelRatio.get()来获取 DPR。</p><p>当然，上面的规则也有例外， iPhone6、7、8Plus的实际物理像素是 1080x1920，在开发者工具中我们可以看到：它的设备独立像素是 414x736，设备像素比为 3，设备独立像素和设备像素比的乘积并不等于 1080x1920，而是等于 1242x2208。</p><p>实际上，手机会自动把 1242x2208个像素点塞进 1080*1920个物理像素点来渲染，我们不用关心这个过程，而 1242x2208被称为屏幕的设计像素。我们开发过程中也是以这个设计像素为准。</p><p>实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。</p><p>紧接着， Android同样使用了其他的技术方案来实现 DPR大于 1的屏幕，不过原理是类似的。由于 Android屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果， Android按照设备的像素密度将设备分成了几个区间：<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/12.webp" alt="12"><br>当然，所有的 Android设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个 Android手机都能根据给定的区间范围，确定自己的 DPR，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种 Android设备仍然不能做到在展示上完全相等。</p><h2 id="3-2-移动端开发"><a href="#3-2-移动端开发" class="headerlink" title="3.2 移动端开发"></a>3.2 移动端开发</h2><p>在 iOS、Android和ReactNative开发中样式单位其实都使用的是设备独立像素。</p><p>iOS的尺寸单位为pt， Android的尺寸单位为dp，ReactNative中没有指定明确的单位，它们其实都是设备独立像素dp。<br>在使用ReactNative开发App时，UI给我们的原型图一般是基于iphone6的像素给定的。</p><p>为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为200px(这里的 px指物理像素，非 CSS像素)，iphone6的设备像素比为2，我们给定的height应为200px/2=100dp。</p><p>当然，最好的是，你可以和设计沟通好，所有的UI图都按照设备独立像素来出。</p><p>我们还可以在代码( ReactNative)中进行 px和 dp的转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123;PixelRatio &#125; from &apos;react-native&apos;;</span><br><span class="line">    const dpr = PixelRatio.get();</span><br><span class="line">/**</span><br><span class="line"> * px转换为dp</span><br><span class="line"> */</span><br><span class="line">export function pxConvertTodp(px) &#123;  </span><br><span class="line">    return px / dpr;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * dp转换为px</span><br><span class="line"> */</span><br><span class="line">export function dpConvertTopx(dp) &#123;</span><br><span class="line">    return PixelRatio.getPixelSizeForLayoutSize(dp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-WEB端开发"><a href="#3-3-WEB端开发" class="headerlink" title="3.3 WEB端开发"></a>3.3 WEB端开发</h2><p>在写CSS时，我们用到最多的单位是px，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。</p><p>但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。</p><p>页面的缩放系数=CSS像素/设备独立像素。</p><h2 id="3-4-关于屏幕"><a href="#3-4-关于屏幕" class="headerlink" title="3.4 关于屏幕"></a>3.4 关于屏幕</h2><p>这里多说两句 Retina屏幕，因为我在很多文章中看到对 Retina屏幕的误解。</p><p>Retina屏幕只是苹果提出的一个营销术语：</p><blockquote><p>在普通的使用距离下，人的肉眼无法分辨单个的像素点。</p></blockquote><p>为什么强调 普通的使用距离下呢？我们来看一下它的计算公式：</p><p>$$ a=2arctan(h/2d) $$</p><p>a代表人眼视角，h代表像素间距，d代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。</p><p>它不能单纯的表达分辨率和PPI，只能一种表达视觉效果。</p><p>让多个物理像素渲染一个独立像素只是Retina屏幕为了达到效果而使用的一种技术。而不是所有DPR&gt;1的屏幕就是Retina屏幕。</p><p>比如：给你一块超大尺寸的屏幕，即使它的PPI很高，DPR也很高，在近距离你也能看清它的像素点，这就不算Retina屏幕。<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/13.webp" alt="13"><br>我们经常见到用K和P这个单位来形容屏幕：</p><p>P代表的就是屏幕纵向的像素个数，1080P即纵向有1080个像素，分辨率为1920X1080的屏幕就属于1080P屏幕。</p><p>我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过1920X1080的屏幕。</p><p>K代表屏幕横向有几个1024个像素，一般来讲横向像素超过2048就属于 2K屏，横向像素超过4096就属于4K屏。</p><h1 id="四、视口"><a href="#四、视口" class="headerlink" title="四、视口"></a>四、视口</h1><p>视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。</p><p>一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。</p><h2 id="4-1-布局视口"><a href="#4-1-布局视口" class="headerlink" title="4.1 布局视口"></a>4.1 布局视口</h2><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/14.webp" alt="14"><br>布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。</p><p>所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括borders 、margins、滚动条）。</p><p>在移动端，布局视口被赋予一个默认值，大部分为980px，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p><p>我们可以通过调用 document.documentElement.clientWidth/clientHeight 来获取布局视口大小。</p><h2 id="4-2-视觉视口"><a href="#4-2-视觉视口" class="headerlink" title="4.2 视觉视口"></a>4.2 视觉视口</h2><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/15.webp" alt="15"><br>视觉视口( visual viewport)：用户通过屏幕真实看到的区域。</p><p>视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。</p><p>当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。</p><p>例如：用户将浏览器窗口放大了 200%，这时浏览器窗口中的 CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨越更多的物理像素。</p><p>所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。</p><p>我们可以通过调用 window.innerWidth/innerHeight来获取视觉视口大小。</p><h2 id="4-3-理想视口"><a href="#4-3-理想视口" class="headerlink" title="4.3 理想视口"></a>4.3 理想视口</h2><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/16.webp" alt="16"><br>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。</p><p>如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。</p><p>上面在介绍CSS像素时曾经提到 页面的缩放系数=CSS像素/设备独立像素，实际上说 页面的缩放系数=理想视口宽度/视觉视口宽度更为准确。</p><p>所以，当页面缩放比例为100%时，CSS像素=设备独立像素， 理想视口=视觉视口。</p><p>我们可以通过调用 screen.width/height来获取理想视口大小。</p><h2 id="4-4-Meta-viewport"><a href="#4-4-Meta-viewport" class="headerlink" title="4.4 Meta viewport"></a>4.4 Meta viewport</h2><p><meta>元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。</p><p>我们可以借助<meta>元素的viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>上面是 viewport的一个配置，我们来看看它们的具体含义：</p><table><thead><tr><th style="text-align:center">Value</th><th style="text-align:center">可能值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">width</td><td style="text-align:center">正整数或 device-width</td><td style="text-align:center">以 pixels（像素）为单位， 定义布局视口的宽度。 </td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">正整数或 device-height</td><td style="text-align:center">以 pixels（像素）为单位， 定义布局视口的高度。</td></tr><tr><td style="text-align:center">initial-scale</td><td style="text-align:center">0.0-10.0</td><td style="text-align:center">定义页面初始缩放比率。</td></tr><tr><td style="text-align:center">minimum-scale</td><td style="text-align:center">0.0-10.0</td><td style="text-align:center">定义缩放的最小值；必须小于或等于 maximum-scale的值。</td></tr><tr><td style="text-align:center">maximum-scale</td><td style="text-align:center">0.0-10.0</td><td style="text-align:center">定义缩放的最大值；必须大于或等于 minimum-scale的值。</td></tr><tr><td style="text-align:center">user-scalable</td><td style="text-align:center">一个布尔值（ yes或者 no）</td><td style="text-align:center">如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。</td></tr></tbody></table><h2 id="4-5-移动端适配"><a href="#4-5-移动端适配" class="headerlink" title="4.5 移动端适配"></a>4.5 移动端适配</h2><p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。</p><p>device-width就等于理想视口的宽度，所以设置 width=device-width 就相当于让布局视口等于理想视口。</p><p>由于 initial-scale=理想视口宽度/视觉视口宽度，所以我们设置 initial-scale=1;就相当于让视觉视口等于理想视口。</p><p>这时，1个CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p><h2 id="4-6-缩放"><a href="#4-6-缩放" class="headerlink" title="4.6 缩放"></a>4.6 缩放</h2><p>上面提到 width可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置initial-scale也有肯能影响到布局视口，因为布局视口宽度取的是 width和视觉视口宽度的最大值。</p><p>例如：若手机的理想视口宽度为 400px，设置 width=device-width， initial-scale=2，此时视觉视口宽度=理想视口宽度/initial-scale即 200px，布局视口取两者最大值即 device-width 400px。</p><p>若设置 width=device-width， initial-scale=0.5，此时视觉视口宽度=理想视口宽度/initial-scale即800px，布局视口取两者最大值即 800px。</p><h2 id="4-7-获取浏览器大小"><a href="#4-7-获取浏览器大小" class="headerlink" title="4.7 获取浏览器大小"></a>4.7 获取浏览器大小</h2><p>浏览器为我们提供的获取窗口大小的 API有很多，下面我们再来对比一下：<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/17.webp" alt="17"></p><ul><li>window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。</li><li>window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。</li><li>window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的， 设备的分辨率/设备像素比</li><li>window.screen.availHeight：浏览器窗口可用的高度。</li><li>document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。</li><li>document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。</li><li>document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与 clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。</li></ul><h1 id="五、1px问题"><a href="#五、1px问题" class="headerlink" title="五、1px问题"></a>五、1px问题</h1><p>为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。</p><p>而在设备像素比大于1的屏幕上，我们写的1px实际上是被多个物理像素渲染，这就会出现1px在有些屏幕上看起来很粗的现象。</p><h2 id="5-1-border-image"><a href="#5-1-border-image" class="headerlink" title="5.1 border-image"></a>5.1 border-image</h2><p>基于 media查询判断不同的设备像素比给定不同的 border-image：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.border_1px&#123;</span><br><span class="line">      border-bottom: 1px solid #000;       </span><br><span class="line">       &#125;        </span><br><span class="line">       @media only screen and (-webkit-min-device-pixel-ratio:2)&#123;           </span><br><span class="line">        .border_1px&#123;</span><br><span class="line">              border-bottom: none;</span><br><span class="line">            border-width: 0 0 1px 0;</span><br><span class="line">            border-image: url(../img/1pxline.png) 0 0 2 0 stretch;            </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-2-background-image"><a href="#5-2-background-image" class="headerlink" title="5.2 background-image"></a>5.2 background-image</h2><p>和 border-image类似，准备一张符合条件的边框背景图，模拟在背景上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.border_1px&#123;</span><br><span class="line">          border-bottom: 1px solid #000;       </span><br><span class="line">       &#125;        </span><br><span class="line">       @media only screen and (-webkit-min-device-pixel-ratio:2)&#123;           </span><br><span class="line">        .border_1px&#123;</span><br><span class="line">            background: url(../img/1pxline.png) repeat-x left bottom;  </span><br><span class="line">            background-size: 100% 1px;          </span><br><span class="line">        &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。</p><h2 id="5-3-伪类-transform"><a href="#5-3-伪类-transform" class="headerlink" title="5.3 伪类 + transform"></a>5.3 伪类 + transform</h2><p>基于 media查询判断不同的设备像素比对线条进行缩放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.border_1px:before&#123;</span><br><span class="line">            content:&quot;&quot; ;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            height: 1px;</span><br><span class="line">           width: 100%;</span><br><span class="line">           background-color: #000;</span><br><span class="line">           transform-origin: 50% 0%;</span><br><span class="line">          &#125;        </span><br><span class="line">          @media only screen and (-webkit-min-device-pixel-ratio:2)&#123;           </span><br><span class="line">           .border_1px:before&#123;</span><br><span class="line">               transeform: scaleY(0.5);        </span><br><span class="line">           &#125;        </span><br><span class="line">           @media only screen and (-webkit-min-device-pixel-ratio:3)&#123;           </span><br><span class="line">           .border_1px:before&#123;</span><br><span class="line">               transeform: scaleY(0.33);        </span><br><span class="line">           &#125;      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上 border-radius即可。</p><h2 id="5-4-svg"><a href="#5-4-svg" class="headerlink" title="5.4 svg"></a>5.4 svg</h2><p>上面我们 border-image和 background-image都可以模拟 1px边框，但是使用的都是位图，还需要外部引入。</p><p>借助 PostCSS的 postcss-write-svg我们能直接使用 border-image和 background-image创建 svg的 1px边框：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@svg border_1px &#123;</span><br><span class="line"> height:   2px ;</span><br><span class="line"> @rect&#123;</span><br><span class="line">     fill:var(--color,black);</span><br><span class="line">     width:100%;</span><br><span class="line">     height:50%;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">.example &#123;</span><br><span class="line"> border: 1px solid transparent;</span><br><span class="line"> border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>编译后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. example &#123;</span><br><span class="line">border :1px solid transparent;</span><br><span class="line"> border -image:url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; height=&apos;2px&apos;%3E%3Crect fill=&apos;%2300b1ff&apos; width=&apos;100%25&apos; height=&apos;50%25&apos;/%3E%3C/svg%3E&quot;)</span><br></pre></td></tr></table></figure></p><p>上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。</p><h2 id="5-5-viewport"><a href="#5-5-viewport" class="headerlink" title="5.5 viewport"></a>5.5 viewport</h2><p>通过设置缩放，让 CSS像素等于真正的物理像素。</p><p>例如：当设备像素比为 3时，我们将页面缩放 1/3倍，这时 1px等于一个真正的屏幕像素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const scale = 1 / window.devicePixelRatio;</span><br><span class="line">const viewport = document.querySelector(&apos;meta[name=&quot;viewport&quot;]&apos;);</span><br><span class="line">if (!viewport) &#123;</span><br><span class="line">    viewport = document.createElement(&apos;meta&apos;);</span><br><span class="line">    viewport.setAttribute(&apos;name&apos;, &apos;viewport&apos;);</span><br><span class="line">    window.document.head.appendChild(viewport);</span><br><span class="line">&#125;</span><br><span class="line">viewport.setAttribute(&apos;content&apos;, &apos;width=device-width,user-scalable=no,initial-scale=&apos; + scale + &apos;,maximum-scale=&apos; + scale + &apos;,minimum-scale=&apos;+ scale);</span><br></pre></td></tr></table></figure></p><p>实际上，上面这种方案是早先 flexible采用的方案。</p><p>当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助 flexible或 vw、vh来帮助我们进行适配。</p><h1 id="六、移动端适配方案"><a href="#六、移动端适配方案" class="headerlink" title="六、移动端适配方案"></a>六、移动端适配方案</h1><p>尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。</p><h2 id="6-1-flexible方案"><a href="#6-1-flexible方案" class="headerlink" title="6.1 flexible方案"></a>6.1 flexible方案</h2><p>flexible方案是阿里早期开源的一个移动端适配解决方案，引用 flexible后，我们在页面上统一使用 rem来布局。</p><p>它的核心代码非常简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// set 1rem = viewWidth / 10</span><br><span class="line">function setRemUnit () &#123;</span><br><span class="line">var rem =docEl  . clientWidth   / 10  docEl .style .ontSize = rem  +&apos;px&apos; &#125;</span><br><span class="line">setRemUnit();</span><br></pre></td></tr></table></figure></p><p>rem 是相对于 html节点的 font-size来做计算的。</p><p>我们通过设置 document.documentElement.style.fontSize就可以统一整个页面的布局标准。</p><p>上面的代码中，将 html节点的 font-size设置为页面 clientWidth(布局视口)的 1/10，即 1rem就等于页面布局视口的 1/10，这就意味着我们后面使用的 rem都是按照页面比例来计算的。</p><p>这时，我们只需要将 UI出的图转换为 rem即可。</p><p>以 iPhone6为例：布局视口为 375px，则 1rem=37.5px，这时 UI给定一个元素的宽为 75px（设备独立像素），我们只需要将它设置为 75/37.5=2rem。</p><p>当然，每个布局都要计算非常繁琐，我们可以借助 PostCSS的 px2rem插件来帮助我们完成这个过程。</p><p>下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了 window的 resize和 pageShow事件之后自动调整 html的 fontSize大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// reset rem unit on page resize</span><br><span class="line">window.addEventListener(&apos;resize&apos;, setRemUnit)</span><br><span class="line">window.addEventListener(&apos;pageshow&apos;, function (e) &#123;</span><br><span class="line">    if (e.persisted) &#123;setRemUnit()&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>由于 viewport单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用：</p><blockquote><p>lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。</p></blockquote><p>下面我们来看看现在最流行的 vh、vw方案。</p><h2 id="6-2-vh-vw方案"><a href="#6-2-vh-vw方案" class="headerlink" title="6.2 vh,vw方案"></a>6.2 vh,vw方案</h2><p>vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。</p><p>上面的 flexible方案就是模仿这种方案，因为早些时候 vw还没有得到很好的兼容。</p><ul><li>vw(Viewport’s width)： 1vw等于视觉视口的 1%</li><li>vh(Viewport’s height) : 1vh 为视觉视口高度的 1%</li><li>vmin : vw 和 vh 中的较小值</li><li>vmax : 选取 vw 和 vh 中的较大值<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/18.webp" alt="18"></li></ul><p>如果视觉视口为 375px，那么 1vw=3.75px，这时 UI给定一个元素的宽为 75px（设备独立像素），我们只需要将它设置为 75/3.75=20vw。</p><p>这里的比例关系我们也不用自己换算，我们可以使用 PostCSS的 postcss-px-to-viewport 插件帮我们完成这个过程。写代码时，我们只需要根据 UI给的设计图写 px单位即可。</p><p>当然，没有一种方案是十全十美的， vw同样有一定的缺陷：</p><ul><li>px转换成 vw不一定能完全整除，因此有一定的像素差。</li><li>比如当容器使用 vw， margin采用 px时，很容易造成整体宽度超过 100vw，从而影响布局效果。当然我们也是可以避免的，例如使用 padding代替 margin，结合 calc()函数使用等等…</li></ul><h1 id="七、适配iPhone-X"><a href="#七、适配iPhone-X" class="headerlink" title="七、适配iPhone X"></a>七、适配iPhone X</h1><p>iPhoneX的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。</p><h1 id="7-1-安全区域"><a href="#7-1-安全区域" class="headerlink" title="7.1 安全区域"></a>7.1 安全区域</h1><p>在 iPhoneX发布后，许多厂商相继推出了具有边缘屏幕的手机。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/19.webp" alt="19"></p><p>这些手机和普通手机在外观上无外乎做了三个改动：圆角（ corners）、刘海（ sensor housing）和小黑条（ HomeIndicator）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。</p><p>为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。</p><h2 id="7-2-viewport-fit"><a href="#7-2-viewport-fit" class="headerlink" title="7.2 viewport-fit"></a>7.2 viewport-fit</h2><p>viewport-fit是专门为了适配 iPhoneX而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/20.webp" alt="20"></p><p>contain: 可视窗口完全包含网页内容</p><p>cover：网页内容完全覆盖可视窗口</p><p>默认情况下或者设置为 auto和 contain效果相同。</p><h2 id="7-3-env、constant"><a href="#7-3-env、constant" class="headerlink" title="7.3 env、constant"></a>7.3 env、constant</h2><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/21.webp" alt="21"><br>我们需要将顶部和底部合理的摆放在安全区域内， iOS11新增了两个 CSS函数 env、constant，用于设定安全区域与边界的距离。</p><p>函数内部可以是四个常量：</p><ul><li>safe-area-inset-left：安全区域距离左边边界距离</li><li>safe-area-inset-right：安全区域距离右边边界距离</li><li>safe-area-inset-top：安全区域距离顶部边界距离</li><li>safe-area-inset-bottom：安全区域距离底部边界距离</li></ul><p>注意：我们必须指定 viweport-fit后才能使用这两个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;viewport-fit=cover&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>constant在 iOS&lt;11.2的版本中生效， env在 iOS&gt;=11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    padding - bottom:constant(safe - area - inset - bottom);</span><br><span class="line">    padding - bottom:env(safe - area - inset - bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用底部固定导航栏时，我们要为他们设置 padding值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    padding - bottom: constant(safe - area - inset - bottom);</span><br><span class="line">    padding - bottom: env(safe - area - inset - bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="八、横屏适配"><a href="#八、横屏适配" class="headerlink" title="八、横屏适配"></a>八、横屏适配</h1><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/22.webp" alt="22"></p><p>很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式：</p><h2 id="8-1-JavaScript检测横屏"><a href="#8-1-JavaScript检测横屏" class="headerlink" title="8.1 JavaScript检测横屏"></a>8.1 JavaScript检测横屏</h2><p>window.orientation:获取屏幕旋转方向<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener (     &quot;resize&quot;     , ()=&gt;&#123;</span><br><span class="line">    if (window.orientation === 180 || window.orientation === 0) &#123;</span><br><span class="line">            // 正常方向或屏幕旋转180度</span><br><span class="line">        console.log(&apos;竖屏&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line">    if (window.orientation === 90 || window.orientation === -90)&#123;</span><br><span class="line">        // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度</span><br><span class="line">        console.log(&apos;横屏&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="8-2-css检测横屏"><a href="#8-2-css检测横屏" class="headerlink" title="8.2 css检测横屏"></a>8.2 css检测横屏</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@mediascreen and(orientation:portrait)&#123;/*竖屏...*/&#125;</span><br><span class="line">@mediascreen and(orientation:landscape)&#123;/*横屏...*/&#125;</span><br></pre></td></tr></table></figure><h1 id="九、图片模糊问题"><a href="#九、图片模糊问题" class="headerlink" title="九、图片模糊问题"></a>九、图片模糊问题</h1><h2 id="9-1-产生原因"><a href="#9-1-产生原因" class="headerlink" title="9.1 产生原因"></a>9.1 产生原因</h2><p>我们平时使用的图片大多数都属于位图（ png、jpg…），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值：</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/23.webp" alt="23"></p><p>理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。</p><p>而在 dpr&gt;1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在 dpr&gt;1的屏幕上就会模糊:</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/24.webp" alt="24"></p><h2 id="9-2-解决方案"><a href="#9-2-解决方案" class="headerlink" title="9.2 解决方案"></a>9.2 解决方案</h2><p>为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同 DPR的屏幕，我们需要展示不同分辨率的图片。</p><p>如：在 dpr=2的屏幕上展示两倍图 (@2x)，在 dpr=3的屏幕上展示三倍图 (@3x)。<br><img src="/2019/06/03/关于移动端适配，你必须要知道的/25.webp" alt="25"></p><h2 id="9-3-media查询"><a href="#9-3-media查询" class="headerlink" title="9.3 media查询"></a>9.3 media查询</h2><p>使用 media查询判断不同的设备像素比来显示不同精度的图片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.avatar&#123;</span><br><span class="line">    background - image:url(conardLi_1x         .         png);</span><br><span class="line">&#125;</span><br><span class="line">@mediaonly screenand(-webkit - min - device - pixel - ratio:2)&#123;</span><br><span class="line">.avatar&#123;</span><br><span class="line">        background - image:url(conardLi_2x.png);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@mediaonly screenand(-webkit - min - device - pixel - ratio:3)&#123;</span><br><span class="line">.avatar&#123;</span><br><span class="line">    background - image:url(conardLi_3x.png);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只适用于背景图</p></blockquote><h2 id="9-4-image-set"><a href="#9-4-image-set" class="headerlink" title="9.4 image-set"></a>9.4 image-set</h2><p>使用 image-set：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.avatar&#123;</span><br><span class="line">    background - image:-webkit - image - set(&quot;conardLi_1x.png&quot;1x, &quot;conardLi_2x.png&quot;2x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>只适用于背景图</p></blockquote><h2 id="9-5-srcset"><a href="#9-5-srcset" class="headerlink" title="9.5 srcset"></a>9.5 srcset</h2><p>使用 img标签的 srcset属性，浏览器会自动根据像素密度匹配最佳显示图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;conardLi_1x.png&quot; srcSet=&quot; conardLi_2x.png 2x, conardLi_3x.png 3x&quot;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="9-6-JavaScript拼接图片url"><a href="#9-6-JavaScript拼接图片url" class="headerlink" title="9.6 JavaScript拼接图片url"></a>9.6 JavaScript拼接图片url</h2><p>使用 window.devicePixelRatio获取设备像素比，遍历所有图片，替换图片地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const dpr = window.devicePixelRatio;</span><br><span class="line">const images = document.querySelectorAll(&apos;img&apos;);</span><br><span class="line">images.forEach((img)=&gt;&#123;</span><br><span class="line">        img.src.replace(&quot;.&quot;, `@$&#123;dpr&#125;x.`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="9-7-使用svg"><a href="#9-7-使用svg" class="headerlink" title="9.7 使用svg"></a>9.7 使用svg</h2><p>SVG的全称是可缩放矢量图（ ScalableVectorGraphics）。不同于位图的基于像素， SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p><p><img src="/2019/06/03/关于移动端适配，你必须要知道的/26.webp" alt="26"><br>除了我们手动在代码中绘制 svg，我们还可以像使用位图一样使用 svg图片：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;conardLi.svg&quot;&gt;</span><br><span class="line">&lt;img src=&quot;data:image/svg+xml;base64,[data]&quot;&gt;</span><br><span class="line">.avatar&#123;</span><br><span class="line">    background:url(conardLi.svg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NDYxNTM0OQ==&amp;amp;mid=2247483747&amp;amp;idx=1&amp;amp;sn=90cb7d69ca1b996809dd02a32078cd5d&amp;amp;chksm=ebf9f6b9dc8e7faf867e5ec22339e65efdb0002bc7d9f1867a53edb8c5318a94a8d13737a269&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=&amp;amp;key=47a58d19edbb3f926e528c56a70e589ae4e1cf407b6c9c8b6d9a12d873ac30d5305221e22dec0e82151432be214eab8486154ff64e20d56ad7cdcb461faaebe75242d05895b2e35d5cc7ed48027ebeee&amp;amp;ascene=1&amp;amp;uin=Mjk1MDEwMzIwNw%3D%3D&amp;amp;devicetype=Windows+10&amp;amp;version=62060739&amp;amp;lang=en&amp;amp;pass_ticket=Kg%2BuI6pXTVeQSCOOiejokLvubZ6zl%2FsBhrz7K%2B4cm%2B%2FtjWT1MFYKGhT2efwdnKdG&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code秘密花园&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;本文有点长，耐心阅读！&lt;br&gt;&lt;img src=&quot;/2019/06/03/关于移动端适配，你必须要知道的/view.jpg&quot; alt=&quot;view&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>学会这两件事，让你成为Git老司机</title>
    <link href="https://Lifuzhen.github.io/2019/02/13/%E5%AD%A6%E4%BC%9A%E8%BF%99%E4%B8%A4%E4%BB%B6%E4%BA%8B%EF%BC%8C%E8%AE%A9%E4%BD%A0%E6%88%90%E4%B8%BAGit%E8%80%81%E5%8F%B8%E6%9C%BA/"/>
    <id>https://Lifuzhen.github.io/2019/02/13/学会这两件事，让你成为Git老司机/</id>
    <published>2019-02-13T10:03:48.000Z</published>
    <updated>2019-05-15T03:59:53.130Z</updated>
    
    <content type="html"><![CDATA[<p>学会这两件事，让你成为 Git 老司机(这个文章的原文我找不到了，没有办法给各位放上原文链接了)</p><p><img src="/2019/02/13/学会这两件事，让你成为Git老司机/00.jpg" alt="00"></p><p>我在提交中犯了个错误，我如何修正它？<br>我的提交历史一团糟，我该如何让它更整洁？</p><p>如果你曾经有上述问题，那么这篇文章很适合你。这篇文章介绍了一个让你成为 Git 老司机的清单。<br><a id="more"></a></p><blockquote><p>我在提交中犯了个错误，我该怎么办？</p></blockquote><p><img src="/2019/02/13/学会这两件事，让你成为Git老司机/error.jpg" alt="00"></p><h3 id="情景-1"><a href="#情景-1" class="headerlink" title="情景 1"></a>情景 1</h3><p>假设你已经提交了一堆文件，并发现输入的提交信息实际上并不清晰。现在你要更改提交消息。为此，你可以使用 git commit –amend：</p><p><code>git commit --amend -m “New commit message”</code></p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景 2"></a>场景 2</h3><p>假设你要提交六个文件，但你最终错误地只提交了五个文件。你可能认为可以创建新提交并将第六个文件添加到该提交。<br>这种方法没错。但是，为了保持整洁的提交历史，如果你可以以某种方式将此文件加入到你之前的提交本身，那岂不是更好？这也可以通过 git commit –amend 完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add file6</span><br><span class="line">git commit --amend --no-edit</span><br></pre></td></tr></table></figure><p>–no-edit 表示提交信息不会更改。</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景 3"></a>场景 3</h3><p>无论你何时在 Git 进行提交，提交都会附上作者名称和作者电子邮箱。通常，当你第一次配置 Git 时，就需要设置作者和电子邮箱。你无需担心每次提交的作者详细信息。<br>也就是说，对于特定项目，你可能希望使用不同的电子邮箱 ID。你需要使用以下命令为该项目配置电子邮箱 ID：</p><p><code>git config user.email “your email id”</code></p><p>假设你忘记配置电子邮箱，并且已经完成了第一次提交。amend 命令也可以用于更改先前提交的作者消息。可以使用以下命令更改提交的作者信息：</p><p><code>git commit --amend --author &quot;Author Name &lt;Author Email&gt;&quot;</code></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>应该仅在本地仓库使用 amend 命令。在远端仓库使用 amend 命令会制造大量混乱。</p><blockquote><p>我的提交历史一团糟，我该如何处理？</p></blockquote><p>假设你正在处理一段代码。你知道代码大约需要十天完成。在这十天内，其他开发人员也将提交代码到远程仓库。<br>将本地仓库代码与远程仓库代码保持同步是个很好的做法。这在你拉取请求时会避免许多合并冲突的操作。因此，你应该每两天从远程仓库中拉取一个变更。<br>每次将代码从远程仓库拉取到本地仓库时，都会在本地操作中创建新的合并提交。这意味着你的本地历史提交记录会有大量的合并提交，这会让审阅人员头大。</p><p><img src="/2019/02/13/学会这两件事，让你成为Git老司机/01.jpg" alt="01"></p><p>上面是历史提交记录在本地仓库中的显示方式。</p><h4 id="如何让历史提交记录看起来更整洁？"><a href="#如何让历史提交记录看起来更整洁？" class="headerlink" title="如何让历史提交记录看起来更整洁？"></a>如何让历史提交记录看起来更整洁？</h4><p>这就需要用到 rebase 了。</p><p>什么是变基（rebase）？</p><h3 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h3><p><img src="/2019/02/13/学会这两件事，让你成为Git老司机/02.jpg" alt="02"></p><p>此图显示了发布（release）分支和功能（feature）分支中的提交。<br>1.发布分支有三个提交：Rcommit1、Rcommit2 和 Rcommit3。<br>2.你在发布分支中仅有一个提交（即 Rcommit1）时，创建了功能分支。<br>3.你已向功能分支添加了两个提交。它们是 Fcommit1 和 Fcommit2。<br>4.你希望从发布分支提交到功能分支中。<br>5.你可以使用变基来完成该操作。<br>6.让发布分支命名为 release，让功能分支命名为 feature。<br>7.可以使用以下命令进行变基：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase release</span><br></pre></td></tr></table></figure></p><h3 id="变基（rebase）"><a href="#变基（rebase）" class="headerlink" title="变基（rebase）"></a>变基（rebase）</h3><p>当执行变基时，你的目标是确保功能分支从发布分支获取最新代码。<br>变基命令尝试逐个添加每个提交，并检查冲突。这听起来是不是有点头大？<br>让我画个图帮助理解。<br>这显示了变基内部实际做的事情：</p><p><img src="/2019/02/13/学会这两件事，让你成为Git老司机/03.jpg" alt="03"></p><p>第 1 步</p><pre><code>1.运行该命令的那一刻，功能分支指向发布分支的头部。2.现在，功能分支有三个提交，Rcommit1、Rcommit2 和 Rcommit3。3.你可能想知道 Rcommit1 和 Rcommit2 发生了什么？4.提交仍然存在，将在下面步骤中使用。</code></pre><p>第 2 步</p><pre><code>1.现在 Git 尝试将 Fcommit1 添加到功能分支上。2.如果没有冲突，则在 Rcommit3 之后添加 Fcommit1；3.如果存在冲突，Git 会通知你，你必须手动解决冲突。解决冲突后，使用以下命令继续变基：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add fixedfile</span><br><span class="line">git rebase --continue</span><br></pre></td></tr></table></figure></code></pre><p>第 3 步</p><pre><code>1.一旦添加了 Fcommit1，Git 将尝试添加 Fcommit2。2.同样，如果没有冲突，则在 Fcommit1 之后添加 Fcommit2，并且变基成功。3.如果存在冲突，Git 会通知你，你必须手动解决。解决冲突后，使用第 2 步提到的相同命令。4.整个变基完成后，你会发现功能分支有 Rcommit1、Rcommit2、Rcommit3、Fcommit1 和 Fcommit2。</code></pre><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>1.变基和合并（merge）在 Git 中都很有用。两种并无优劣之分。<br>2.在合并的情况下，你将有个合并提交。在变基的情况下，不会像合并提交那样有额外的提交。<br>3.一种最佳的实践是一分为二。使用远端仓库中的最新代码更新本地仓库时，请使用变基。在处理拉取请求，以将功能分支和发布分支或主分支合并时，请使用合并。<br>4.将功能分支和发布分支或主分支合并时，请使用合并。使用变基会更改历史提交记录（使其更整洁）。但话虽如此，改变历史提交存在风险。因此，请确保永远不要对远程存储仓库的代码使用变基。始终仅对本地仓库代码使用变基，来更改历史提交记录。<br>5.如果对远端仓库进行变基，会制造许多混乱，因为其他开发人员无法识别新的历史记录。<br>6.此外，如果在远端仓库上完成变基，则当其他开发人员尝试从远端仓库中拉取最新代码时，就可能会出问题。所以，我再重申一遍，变基总是仅在本地仓库中进行。😃</p></blockquote><p>恭喜</p><p>你现在是个 Git 老司机了。😃</p><p>在这篇文章中，你了解到：</p><ul><li>修改提交记录</li><li>变基</li></ul><p>这两个都是非常实用的概念。探索 Git 的世界，继续学习吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学会这两件事，让你成为 Git 老司机(这个文章的原文我找不到了，没有办法给各位放上原文链接了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/13/学会这两件事，让你成为Git老司机/00.jpg&quot; alt=&quot;00&quot;&gt;&lt;/p&gt;
&lt;p&gt;我在提交中犯了个错误，我如何修正它？&lt;br&gt;我的提交历史一团糟，我该如何让它更整洁？&lt;/p&gt;
&lt;p&gt;如果你曾经有上述问题，那么这篇文章很适合你。这篇文章介绍了一个让你成为 Git 老司机的清单。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="git" scheme="https://Lifuzhen.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://Lifuzhen.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Object.keys方法之详解</title>
    <link href="https://Lifuzhen.github.io/2019/02/11/Object-keys%E6%96%B9%E6%B3%95%E4%B9%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>https://Lifuzhen.github.io/2019/02/11/Object-keys方法之详解/</id>
    <published>2019-02-11T10:32:00.000Z</published>
    <updated>2019-05-15T03:59:53.115Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="https://blog.csdn.net/suwu150/article/details/60965257" target="_blank" rel="noopener">Object.keys方法之详解</a>.</p><p><img src="/2019/02/11/Object-keys方法之详解/object.jpg" alt="Object.keys方法之详解"><br><a id="more"></a></p><h1 id="Object-keys方法之详解"><a href="#Object-keys方法之详解" class="headerlink" title="Object.keys方法之详解"></a>Object.keys方法之详解</h1><p>   在实际开发中，我们有时需要知道对象的所有属性，原生js给我们提供了一个很好的方法：Object.keys()，该方法返回一个数组,其中这个数组的内容就是这个对象的所有键值</p><p>传入对象，返回属性名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&apos;a&apos;:&apos;123&apos;,&apos;b&apos;:&apos;345&apos;&#125;;</span><br><span class="line">console.log(Object.keys(obj));  //[&apos;a&apos;,&apos;b&apos;]</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; 100: &quot;a&quot;, 2: &quot;b&quot;, 7: &quot;c&quot;&#125;;</span><br><span class="line">console.log(Object.keys(obj1)); // console: [&quot;2&quot;, &quot;7&quot;, &quot;100&quot;]</span><br><span class="line"></span><br><span class="line">var obj2 = Object.create(&#123;&#125;, &#123; getFoo : &#123; value : function () &#123; return this.foo &#125; &#125; &#125;);</span><br><span class="line">obj2.foo = 1;</span><br><span class="line">console.log(Object.keys(obj2)); // console: [&quot;foo&quot;]</span><br></pre></td></tr></table></figure><p>传入字符串，返回索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;ab1234&apos;;</span><br><span class="line">console.log(Object.keys(str));  //[0,1,2,3,4,5]</span><br></pre></td></tr></table></figure><p>如果我们想要获取字符串中的某一个值,那么我们就可以通过下面的方法获取:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var str = &apos;ab1234&apos;;</span><br><span class="line">console.log(Object.keys(str));  //[0,1,2,3,4,5]</span><br><span class="line"></span><br><span class="line">Object.keys(str).map(function (index) &#123;</span><br><span class="line">  console.log(str[index]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>获取的结果如下面所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos; ]</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p><p>我们可以进行自己的处理</p><p>构造函数 返回空数组或者属性名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Pasta(name, age, gender) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.toString = function () &#123;</span><br><span class="line">                return (this.name + &quot;, &quot; + this.age + &quot;, &quot; + this.gender);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Object.keys(Pasta)); //console: []</span><br><span class="line">var spaghetti = new Pasta(&quot;Tom&quot;, 20, &quot;male&quot;);</span><br><span class="line">console.log(Object.keys(spaghetti)); //console: [&quot;name&quot;, &quot;age&quot;, &quot;gender&quot;, &quot;toString&quot;]</span><br></pre></td></tr></table></figure></p><p>数组 返回索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">console.log(Object.keys(arr)); // console: [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure></p><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p>In ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be coerced to an object.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(&quot;foo&quot;);</span><br><span class="line">// TypeError: &quot;foo&quot; is not an object (ES5 code)</span><br><span class="line"></span><br><span class="line">Object.keys(&quot;foo&quot;);</span><br><span class="line">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]                   (ES6 code)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自 &lt;a href=&quot;https://blog.csdn.net/suwu150/article/details/60965257&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Object.keys方法之详解&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/11/Object-keys方法之详解/object.jpg&quot; alt=&quot;Object.keys方法之详解&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript instanceof 运算符深入剖析</title>
    <link href="https://Lifuzhen.github.io/2018/11/13/JavaScript-instanceof-%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
    <id>https://Lifuzhen.github.io/2018/11/13/JavaScript-instanceof-运算符深入剖析/</id>
    <published>2018-11-13T10:12:14.000Z</published>
    <updated>2019-05-15T03:59:53.107Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自 <a href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html" target="_blank" rel="noopener">IBM developerWorks  姜 俊杰</a>。因自认为讲解的非常好，所以copy一份！</p><p><img src="/2018/11/13/JavaScript-instanceof-运算符深入剖析/intanceof.jpg" alt="intanceof"><br><a id="more"></a></p><h1 id="instanceof-运算符简介"><a href="#instanceof-运算符简介" class="headerlink" title="instanceof 运算符简介"></a>instanceof 运算符简介</h1><p>在 JavaScript 中，判断一个变量的类型尝尝会用 typeof 运算符，在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如：</p><p>清单 1. instanceof 示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var oStringObject = new String(&quot;hello world&quot;);</span><br><span class="line">console.log(oStringObject instanceof String);   // 输出 &quot;true&quot;</span><br></pre></td></tr></table></figure></p><p>这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是”true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。</p><h1 id="instanceof-运算符的常规用法"><a href="#instanceof-运算符的常规用法" class="headerlink" title="instanceof 运算符的常规用法"></a>instanceof 运算符的常规用法</h1><p>通常来讲，使用 instanceof 就是判断一个实例是否属于某种类型。例如：</p><p>清单 2. instanceof 常规用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 判断 foo 是否是 Foo 类的实例</span><br><span class="line">function Foo()&#123;&#125;</span><br><span class="line">var foo = new Foo();</span><br><span class="line">console.log(foo instanceof Foo)//true</span><br></pre></td></tr></table></figure></p><p>另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。例如：</p><p>清单 3. instanceof 在继承中关系中的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 判断 foo 是否是 Foo 类的实例 , 并且是否是其父类型的实例</span><br><span class="line">function Aoo()&#123;&#125;</span><br><span class="line">function Foo()&#123;&#125;</span><br><span class="line">Foo.prototype = new Aoo();//JavaScript 原型继承</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">console.log(foo instanceof Foo)//true</span><br><span class="line">console.log(foo instanceof Aoo)//true</span><br></pre></td></tr></table></figure></p><p>上面的代码中是判断了一层继承关系中的父类，在多层继承关系中，instanceof 运算符同样适用。</p><h1 id="真的了解-instanceof-操作符吗？"><a href="#真的了解-instanceof-操作符吗？" class="headerlink" title="真的了解 instanceof 操作符吗？"></a>真的了解 instanceof 操作符吗？</h1><p>看了上面的代码示例，是不是觉得 instanceof 操作符很简单，下面来看点复杂的用法。</p><p>清单 4. instanceof 复杂用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object instanceof Object);//true</span><br><span class="line">console.log(Function instanceof Function);//true</span><br><span class="line">console.log(Number instanceof Number);//false</span><br><span class="line">console.log(String instanceof String);//false</span><br><span class="line"></span><br><span class="line">console.log(Function instanceof Object);//true</span><br><span class="line"></span><br><span class="line">console.log(Foo instanceof Function);//true</span><br><span class="line">console.log(Foo instanceof Foo);//false</span><br></pre></td></tr></table></figure></p><p>看了上面的代码是不是又晕头转向了？为什么 Object 和 Function instanceof 自己等于 true，而其他类 instanceof 自己却又不等于 true 呢？如何解释？要想从根本上了解 instanceof 的奥秘，需要从两个方面着手：1，语言规范中是如何定义这个运算符的。2，JavaScript 原型继承机制。</p><h1 id="详细剖析-ECMAScript-262-edition-3-中-instanceof-运算符的定义"><a href="#详细剖析-ECMAScript-262-edition-3-中-instanceof-运算符的定义" class="headerlink" title="详细剖析 ECMAScript-262 edition 3 中 instanceof 运算符的定义"></a>详细剖析 ECMAScript-262 edition 3 中 instanceof 运算符的定义</h1><p>语言规范对中 instanceof 运算符的定义如下：</p><p>清单 5. 规范中 instanceof 运算符定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">11.8.6 The instanceof operator</span><br><span class="line"> The production RelationalExpression:</span><br><span class="line">     RelationalExpression instanceof ShiftExpression is evaluated as follows:</span><br><span class="line"></span><br><span class="line"> 1. Evaluate RelationalExpression.</span><br><span class="line"> 2. Call GetValue(Result(1)).// 调用 GetValue 方法得到 Result(1) 的值，设为 Result(2)</span><br><span class="line"> 3. Evaluate ShiftExpression.</span><br><span class="line"> 4. Call GetValue(Result(3)).// 同理，这里设为 Result(4)</span><br><span class="line"> 5. If Result(4) is not an object, throw a TypeError exception.// 如果 Result(4) 不是 object，</span><br><span class="line">                                                                //抛出异常</span><br><span class="line"> /* 如果 Result(4) 没有 [[HasInstance]] 方法，抛出异常。规范中的所有 [[...]] 方法或者属性都是内部的，</span><br><span class="line">在 JavaScript 中不能直接使用。并且规范中说明，只有 Function 对象实现了 [[HasInstance]] 方法。</span><br><span class="line">所以这里可以简单的理解为：如果 Result(4) 不是 Function 对象，抛出异常 */</span><br><span class="line"> 6. If Result(4) does not have a [[HasInstance]] method,</span><br><span class="line">   throw a TypeError exception.</span><br><span class="line"> // 相当于这样调用：Result(4).[[HasInstance]](Result(2))</span><br><span class="line"> 7. Call the [[HasInstance]] method of Result(4) with parameter Result(2).</span><br><span class="line"> 8. Return Result(7).</span><br><span class="line"></span><br><span class="line"> // 相关的 HasInstance 方法定义</span><br><span class="line"> 15.3.5.3 [[HasInstance]] (V)</span><br><span class="line"> Assume F is a Function object.// 这里 F 就是上面的 Result(4)，V 是 Result(2)</span><br><span class="line"> When the [[HasInstance]] method of F is called with value V,</span><br><span class="line">     the following steps are taken:</span><br><span class="line"> 1. If V is not an object, return false.// 如果 V 不是 object，直接返回 false</span><br><span class="line"> 2. Call the [[Get]] method of F with property name &quot;prototype&quot;.// 用 [[Get]] 方法取</span><br><span class="line">                                                                // F 的 prototype 属性</span><br><span class="line"> 3. Let O be Result(2).//O = F.[[Get]](&quot;prototype&quot;)</span><br><span class="line"> 4. If O is not an object, throw a TypeError exception.</span><br><span class="line"> 5. Let V be the value of the [[Prototype]] property of V.//V = V.[[Prototype]]</span><br><span class="line"> 6. If V is null, return false.</span><br><span class="line"> // 这里是关键，如果 O 和 V 引用的是同一个对象，则返回 true；否则，到 Step 8 返回 Step 5 继续循环</span><br><span class="line"> 7. If O and V refer to the same object or if they refer to objects</span><br><span class="line">   joined to each other (section 13.1.2), return true.</span><br><span class="line"> 8. Go to step 5.</span><br></pre></td></tr></table></figure></p><p>上面的规范定义很晦涩，而且看起来比较复杂，涉及到很多概念，但把这段规范翻译成 JavaScript 代码却很简单，如下：</p><p>清单 6. JavaScript instanceof 运算符代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function instance_of(L, R) &#123;//L 表示左表达式，R 表示右表达式</span><br><span class="line"> var O = R.prototype;// 取 R 的显示原型</span><br><span class="line"> L = L.__proto__;// 取 L 的隐式原型</span><br><span class="line"> while (true) &#123;</span><br><span class="line">   if (L === null)</span><br><span class="line">     return false;</span><br><span class="line">   if (O === L)// 这里重点：当 O 严格等于 L 时，返回 true</span><br><span class="line">     return true;</span><br><span class="line">   L = L.__proto__;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="JavaScript-原型继承机制"><a href="#JavaScript-原型继承机制" class="headerlink" title="JavaScript 原型继承机制"></a>JavaScript 原型继承机制</h1><p>由于本文主要集中在剖析 JavaScript instanceof 运算符，所以对于 JavaScript 的原型继承机制不再做详细的讲解，下面参考来自 <a href="http://www.mollypages.org/misc/js.mp" target="_blank" rel="noopener">http://www.mollypages.org/misc/js.mp</a> 的一张图片，此图片详细的描述了 JavaScript 各种对象的显示和隐式原型链结构。</p><p>由其本文涉及显示原型和隐式原型，所以下面对这两个概念作一下简单说明。在 JavaScript 原型继承结构里面，规范中用 [[Prototype]] 表示对象隐式的原型，在 JavaScript 中用 <strong>proto</strong> 表示，并且在 Firefox 和 Chrome 浏览器中是可以访问得到这个属性的，但是 IE 下不行。所有 JavaScript 对象都有 <strong>proto</strong> 属性，但只有 Object.prototype.<strong>proto</strong> 为 null，前提是没有在 Firefox 或者 Chrome 下修改过这个属性。这个属性指向它的原型对象。 至于显示的原型，在 JavaScript 里用 prototype 属性表示，这个是 JavaScript 原型继承的基础知识，在这里就不在叙述了。</p><p>图 1. JavaScript 原型链</p><p><img src="/2018/11/13/JavaScript-instanceof-运算符深入剖析/原型链.jpg" alt="原型链"></p><h1 id="讲解-instanceof-复杂用法"><a href="#讲解-instanceof-复杂用法" class="headerlink" title="讲解 instanceof 复杂用法"></a>讲解 instanceof 复杂用法</h1><p>有了上面 instanceof 运算符的 JavaScript 代码和原型继承图，再来理解 instanceof 运算符将易如反掌。下面将详细讲解 Object instanceof Object，Function instanceof Function 和 Foo instanceof Foo 三个示例，其它示例读者可自行推演。</p><p>清单 7. Object instanceof Object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 为了方便表述，首先区分左侧表达式和右侧表达式</span><br><span class="line">ObjectL = Object, ObjectR = Object;</span><br><span class="line">// 下面根据规范逐步推演</span><br><span class="line">O = ObjectR.prototype = Object.prototype</span><br><span class="line">L = ObjectL.__proto__ = Function.prototype</span><br><span class="line">// 第一次判断</span><br><span class="line">O != L</span><br><span class="line">// 循环查找 L 是否还有 __proto__</span><br><span class="line">L = Function.prototype.__proto__ = Object.prototype</span><br><span class="line">// 第二次判断</span><br><span class="line">O == L</span><br><span class="line">// 返回 true</span><br></pre></td></tr></table></figure></p><p>清单 8. Function instanceof Function<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 为了方便表述，首先区分左侧表达式和右侧表达式</span><br><span class="line">FunctionL = Function, FunctionR = Function;</span><br><span class="line">// 下面根据规范逐步推演</span><br><span class="line">O = FunctionR.prototype = Function.prototype</span><br><span class="line">L = FunctionL.__proto__ = Function.prototype</span><br><span class="line">// 第一次判断</span><br><span class="line">O == L</span><br><span class="line">// 返回 true</span><br></pre></td></tr></table></figure></p><p>清单 9. Foo instanceof Foo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 为了方便表述，首先区分左侧表达式和右侧表达式</span><br><span class="line">FooL = Foo, FooR = Foo;</span><br><span class="line">// 下面根据规范逐步推演</span><br><span class="line">O = FooR.prototype = Foo.prototype</span><br><span class="line">L = FooL.__proto__ = Function.prototype</span><br><span class="line">// 第一次判断</span><br><span class="line">O != L</span><br><span class="line">// 循环再次查找 L 是否还有 __proto__</span><br><span class="line">L = Function.prototype.__proto__ = Object.prototype</span><br><span class="line">// 第二次判断</span><br><span class="line">O != L</span><br><span class="line">// 再次循环查找 L 是否还有 __proto__</span><br><span class="line">L = Object.prototype.__proto__ = null</span><br><span class="line">// 第三次判断</span><br><span class="line">L == null</span><br><span class="line">// 返回 false</span><br></pre></td></tr></table></figure></p><h1 id="简析-instanceof-在-Dojo-继承机制中的应用"><a href="#简析-instanceof-在-Dojo-继承机制中的应用" class="headerlink" title="简析 instanceof 在 Dojo 继承机制中的应用"></a>简析 instanceof 在 Dojo 继承机制中的应用</h1><p>在 JavaScript 中，是没有多重继承这个概念的，就像 Java 一样。但在 Dojo 中使用 declare 声明类时，是允许继承自多个类的。下面以 Dojo 1.6.1 为例。</p><p>清单 10. Dojo 中多重继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dojo.declare(&quot;Aoo&quot;,null,&#123;&#125;);</span><br><span class="line">dojo.declare(&quot;Boo&quot;,null,&#123;&#125;);</span><br><span class="line">dojo.declare(&quot;Foo&quot;,[Aoo,Boo],&#123;&#125;);</span><br><span class="line"></span><br><span class="line">var foo = new Foo();</span><br><span class="line">console.log(foo instanceof Aoo);//true</span><br><span class="line">console.log(foo instanceof Boo);//false</span><br><span class="line"></span><br><span class="line">console.log(foo.isInstanceOf(Aoo));//true</span><br><span class="line">console.log(foo.isInstanceOf(Boo));//true</span><br></pre></td></tr></table></figure></p><p>上面的示例中，Foo 同时继承自 Aoo 和 Boo，但当使用 instanceof 运算符来检查 foo 是否是 Boo 的实例时，返回的是 false。实际上，在 Dojo 的内部，Foo 仍然只继承自 Aoo，而通过 mixin 机制把 Boo 类中的方法和属性拷贝到 Foo 中，所以当用 instanceof 运算符来检查是否是 Boo 的实例时，会返回 false。所以 Dojo 为每个类的实例添加了一个新的方法叫 isInstanceOf，用这个方法来检查多重继承。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转自 &lt;a href=&quot;https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IBM developerWorks  姜 俊杰&lt;/a&gt;。因自认为讲解的非常好，所以copy一份！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/11/13/JavaScript-instanceof-运算符深入剖析/intanceof.jpg&quot; alt=&quot;intanceof&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="https://Lifuzhen.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>跟随鼠标移动的狗狗</title>
    <link href="https://Lifuzhen.github.io/2018/09/24/%E8%B7%9F%E9%9A%8F%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E7%9A%84%E7%8B%97%E7%8B%97/"/>
    <id>https://Lifuzhen.github.io/2018/09/24/跟随鼠标移动的狗狗/</id>
    <published>2018-09-24T03:58:55.000Z</published>
    <updated>2019-05-15T03:59:53.141Z</updated>
    
    <content type="html"><![CDATA[<p> 今天是2018年的中秋佳节，在这里先祝福大家：千好万好事事好，月圆情圆人团圆！</p><p> 因为下载了一个screenToGif软件，录制gif动图停不下来</p><h1 id="跟随鼠标移动的小狗狗"><a href="#跟随鼠标移动的小狗狗" class="headerlink" title="跟随鼠标移动的小狗狗"></a>跟随鼠标移动的小狗狗</h1><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line">!function()&#123;</span><br><span class="line">        class DogAnimation &#123;</span><br><span class="line">            constructor (canvas) &#123;</span><br><span class="line">                this.canvas = canvas;</span><br><span class="line">                canvas.width = window.innerWidth;</span><br><span class="line">                window.onresize = () =&gt; canvas.width = window.innerWidth;</span><br><span class="line">                canvas.height = 200;</span><br><span class="line">                //记录上一帧的时间</span><br><span class="line">                this.lastWalkingTime = Date.now();</span><br><span class="line">                //记录当前画的图片的索引</span><br><span class="line">                this.keyFrameIndex = -1;</span><br><span class="line">                this.ctx = this.canvas.getContext(&quot;2d&quot;);</span><br><span class="line">                //图片目录</span><br><span class="line">                this.RES_PATH = &quot;./dog&quot;;</span><br><span class="line">                this.IMG_COUNT = 8;</span><br><span class="line">                this.dog = &#123;</span><br><span class="line">                    //一步10px</span><br><span class="line">                    stepDistance: 9,</span><br><span class="line">                    //小狗的速度</span><br><span class="line">                    speed: 0.15,</span><br><span class="line">                    //鼠标的x坐标</span><br><span class="line">                    mouseX: -1,</span><br><span class="line">                    //往前走停留的位置</span><br><span class="line">                    frontStopX: -1,</span><br><span class="line">                    //往回走停留的位置</span><br><span class="line">                    backStopX: window.innerWidth,</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            async start () &#123;</span><br><span class="line">            //等待志愿加载完</span><br><span class="line">            await this.loadResources();</span><br><span class="line">            this.pictureWidth = this.dogPictures[0].naturalWidth / 2;</span><br><span class="line">            this.dog.mouseX = window.innerWidth - this.pictureWidth;</span><br><span class="line">            this.recordMousePosition();</span><br><span class="line">            window.requestAnimationFrame(this.walk.bind(this));</span><br><span class="line">        &#125;</span><br><span class="line">            //记录鼠标位置</span><br><span class="line">            recordMousePosition() &#123;</span><br><span class="line">                window.addEventListener(&quot;mousemove&quot;, event =&gt; &#123;</span><br><span class="line">                    //如果没有剪掉图片的宽度，小狗就跑到鼠标后面去了，因为图片的宽度还要占去空间</span><br><span class="line">                        this.dog.frontStopX = event.clientX - this.pictureWidth;</span><br><span class="line">                this.dog.backStopX = event.clientX;</span><br><span class="line">            &#125;);</span><br><span class="line">                window.addEventListener(&quot;touchstart&quot;, event =&gt; &#123;</span><br><span class="line">                    this.dog.frontStopX = event.touches[0].clientX</span><br><span class="line">                    - this.pictureWidth;</span><br><span class="line">                this.dog.backStopX = event.touches[0].clientX;</span><br><span class="line">            &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            //加载图片</span><br><span class="line">            loadResources () &#123;</span><br><span class="line">                //存放加载后狗的图片</span><br><span class="line">                let imagesPath = [];</span><br><span class="line">                //准备图片的src</span><br><span class="line">                for (let i = 0; i &lt;= this.IMG_COUNT; i++) &#123;</span><br><span class="line">                    imagesPath.push(`$&#123;this.RES_PATH&#125;/$&#123;i&#125;.png`);</span><br><span class="line">                &#125;</span><br><span class="line">                let works = [];</span><br><span class="line">                imagesPath.forEach(imgPath =&gt; &#123;</span><br><span class="line">                    //图片加载完成后触发Promise和resolve</span><br><span class="line">                    works.push(new Promise(resolve =&gt; &#123;</span><br><span class="line">                        let img = new Image();</span><br><span class="line">                img.onload = () =&gt; resolve(img);</span><br><span class="line">                img.src = imgPath;</span><br><span class="line">            &#125;));</span><br><span class="line">            &#125;);</span><br><span class="line">                return new Promise(resolve =&gt; &#123;</span><br><span class="line">                    //借助Promise.all知道了所有图片都加载好了</span><br><span class="line">                    Promise.all(works).then(dogPictures =&gt; &#123;</span><br><span class="line">                    this.dogPictures = dogPictures;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;);</span><br><span class="line">            &#125;);//这里再套一个Promise是为了让调用者能够知道处理好了</span><br><span class="line">            &#125;</span><br><span class="line">            walk () &#123;</span><br><span class="line">                let now = Date.now();</span><br><span class="line">                //计算位移 = 时间 * 速度</span><br><span class="line">                let diffDistance = (now - this.lastWalkingTime)</span><br><span class="line">                    * this.dog.speed;</span><br><span class="line">                if (diffDistance &lt; this.dog.stepDistance) &#123;</span><br><span class="line">                    //给下一帧注册一个函数</span><br><span class="line">                    window.requestAnimationFrame(this.walk.bind(this));</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                //获取下一张图片的索引</span><br><span class="line">                this.keyFrameIndex = ++this.keyFrameIndex % this.IMG_COUNT;</span><br><span class="line">                //direct表示小狗的方向；stopWalking表示小狗是否停下来</span><br><span class="line">                let direct = -1, stopWalking = false;</span><br><span class="line">                //如果鼠标在狗的前面则往前走</span><br><span class="line">                if (this.dog.frontStopX &gt; this.dog.mouseX) &#123;</span><br><span class="line">                    direct = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果鼠标在狗的后面则往后走</span><br><span class="line">                else if (this.dog.backStopX &lt; this.dog.mouseX) &#123;</span><br><span class="line">                    direct = -1;</span><br><span class="line">                &#125;</span><br><span class="line">                //如果鼠标在狗的位置</span><br><span class="line">                else &#123;</span><br><span class="line">                    stopWalking = true;</span><br><span class="line">                    //如果鼠标在小狗图片中间的右边，则direct为正，否则为负</span><br><span class="line">                    direct = this.dog.frontStopX === -1 ? -1 :</span><br><span class="line">                        this.dog.backStopX - this.dog.mouseX</span><br><span class="line">                        &gt; this.pictureWidth / 2 ? 1 : -1;</span><br><span class="line">                    //如果停住的话用0.png</span><br><span class="line">                    this.keyFrameIndex = -1;</span><br><span class="line">                    //this.dog.mouseX = this.dog.stopX;</span><br><span class="line">                &#125;</span><br><span class="line">                let ctx = this.ctx;</span><br><span class="line">                //清掉上次画的内容</span><br><span class="line">                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);</span><br><span class="line"></span><br><span class="line">                ctx.save();</span><br><span class="line">                //如果没有停，计算位置的时候乘以direct</span><br><span class="line">                if (!stopWalking) &#123;</span><br><span class="line">                    this.dog.mouseX += this.dog.stepDistance * direct;</span><br><span class="line">                &#125;</span><br><span class="line">                if (direct === -1) &#123;</span><br><span class="line">                    //左右翻转绘制</span><br><span class="line">                    ctx.scale(direct, 1);</span><br><span class="line">                &#125;</span><br><span class="line">                let img = this.dogPictures[this.keyFrameIndex + 1];</span><br><span class="line">                let drawX = 0;</span><br><span class="line">                //左右翻转绘制的位置需要计算一下</span><br><span class="line">                drawX = this.dog.mouseX * direct -</span><br><span class="line">                    (direct === -1 ? this.pictureWidth : 0);</span><br><span class="line">                ctx.drawImage(img, 0, 0, img.naturalWidth,</span><br><span class="line">                    img.naturalHeight,drawX, 20, 186, 162);</span><br><span class="line">                ctx.restore();</span><br><span class="line">                this.lastWalkingTime = now;</span><br><span class="line">                //继续给下一帧注册一个函数</span><br><span class="line">                window.requestAnimationFrame(this.walk.bind(this));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        let canvas = document.querySelector(&quot;#dog-walking&quot;);</span><br><span class="line">        let dogAnimation = new DogAnimation(canvas);</span><br><span class="line">        dogAnimation.start();</span><br><span class="line">    &#125;();</span><br></pre></td></tr></table></figure><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas id=&quot;dog-walking&quot; width=&quot;0&quot; height=&quot;0&quot;</span><br><span class="line">           style=&quot;position:fixed;bottom:0;left:0&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure><h2 id="实现的效果"><a href="#实现的效果" class="headerlink" title="实现的效果"></a>实现的效果</h2><p><img src="/2018/09/24/跟随鼠标移动的狗狗/狗狗.gif" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 今天是2018年的中秋佳节，在这里先祝福大家：千好万好事事好，月圆情圆人团圆！&lt;/p&gt;
&lt;p&gt; 因为下载了一个screenToGif软件，录制gif动图停不下来&lt;/p&gt;
&lt;h1 id=&quot;跟随鼠标移动的小狗狗&quot;&gt;&lt;a href=&quot;#跟随鼠标移动的小狗狗&quot; class=&quot;he
      
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>css 变形、过渡、动画</title>
    <link href="https://Lifuzhen.github.io/2018/09/20/css-%E5%8F%98%E5%BD%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB/"/>
    <id>https://Lifuzhen.github.io/2018/09/20/css-变形、过渡、动画/</id>
    <published>2018-09-20T10:38:00.000Z</published>
    <updated>2019-05-15T03:59:53.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过渡-transition"><a href="#过渡-transition" class="headerlink" title="过渡 ( transition )"></a>过渡 ( transition )</h1><p>过渡属性用法： transition : ransition-property  transition-duration  transition-timing-function transition-delay</p><p> transition-property : 规定设置过渡效果的 CSS 属性的名称(如：width,height,all)。<br> transition-duration : 规定完成过渡效果需要多少秒或毫秒。<br> transition-timing-function : 规定速度效果的速度曲线。<br>    取值：<br>    ease 逐渐变慢（默认值）<br>    linear 匀速<br>    ease-in 加速<br>    ease-out 减速<br>    ease-in-out  先加速后减速<br> transition-delay    定义过渡效果何时开始（延迟多长时间）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.transition&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    transition: width 2s ease-in-out;</span><br><span class="line">&#125;</span><br><span class="line">.transition:hover&#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;transition&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/transition.gif" alt="transition"></p><h1 id="变形-transform"><a href="#变形-transform" class="headerlink" title="变形 ( transform )"></a>变形 ( transform )</h1><h2 id="2D-变形"><a href="#2D-变形" class="headerlink" title="2D 变形"></a>2D 变形</h2><h3 id="移动-translate"><a href="#移动-translate" class="headerlink" title="移动 ( translate )"></a>移动 ( translate )</h3><p>移动可以指定像素值也可以指定百分比，注意：指定百分比是自身大小的百分比，因此可以用于设置盒子定位时的居中对齐（在设置left：50%后再移动自身的-50%即可）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.translate &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: #f90;</span><br><span class="line">    transition: all 2s;</span><br><span class="line">&#125;</span><br><span class="line">.translate:hover &#123;</span><br><span class="line">    transform: translate(300px, 100px);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;translate&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/translate2d01.gif" alt="translate2d01"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> .translate-father &#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    transition: all 0.5s;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.translate-son&#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;translate-father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;translate-son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/translate.png" alt="translate"></p><h3 id="缩放-scale（x，y）"><a href="#缩放-scale（x，y）" class="headerlink" title="缩放 scale（x，y）"></a>缩放 scale（x，y）</h3><p>x,y设置大于1 是放大，小于1 是缩小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.scale&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">    transition: all 2s;</span><br><span class="line">&#125;</span><br><span class="line">.scale:hover&#123;</span><br><span class="line">    transform: scale(0.5, 2);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;scale&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/scale.gif" alt="scale"></p><h3 id="rotate-x-deg"><a href="#rotate-x-deg" class="headerlink" title="rotate (x deg)"></a>rotate (x deg)</h3><p>x指定度数值，正数是顺时针旋转，负数是逆时针旋转。<br>旋转可以使用transform-origin 指定旋转中心点，transform-origin 给left top right bottom 也可以指定具体的像素值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.rotate&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">    transition: all 2s;</span><br><span class="line">    transform-origin: bottom left;</span><br><span class="line">&#125;</span><br><span class="line">.rotate:hover&#123;</span><br><span class="line">    transform: rotate(-120deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;rotate&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/rotate2d.gif" alt="rotate2d"></p><h3 id="skew（x-deg-y-deg）"><a href="#skew（x-deg-y-deg）" class="headerlink" title="skew（x deg ,y deg）"></a>skew（x deg ,y deg）</h3><p>x,y分别指定倾斜在x，y方向上的角度，可以为负数。y值不写默认为0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.skew&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    border: 2px solid #fff;</span><br><span class="line">    border-top-color: red;</span><br><span class="line">    border-left-color: green;</span><br><span class="line">    border-right-color: black;</span><br><span class="line">    border-bottom-color: blue;</span><br><span class="line">    transition: all 1s;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">&#125;</span><br><span class="line">.skew:hover&#123;</span><br><span class="line">    transform: skew(30deg,-50deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;skew&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/skew.gif" alt="skew"></p><h2 id="3D-变形"><a href="#3D-变形" class="headerlink" title="3D 变形"></a>3D 变形</h2><h3 id="旋转（rotateX-rotateY-rotateZ）"><a href="#旋转（rotateX-rotateY-rotateZ）" class="headerlink" title="旋转（rotateX,rotateY,rotateZ）"></a>旋转（rotateX,rotateY,rotateZ）</h3><p>3D旋转与2D类似，只不过一个是基于二位坐标一个是基于三维坐标。三个值可以同时指定也可以单独指定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.rotate&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">    transition: all 2s;</span><br><span class="line">    transform-origin: bottom left;</span><br><span class="line">&#125;</span><br><span class="line">.rotate:hover&#123;</span><br><span class="line">    transform: rotateY(180deg);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;rotate&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p> 实现的效果:<br><img src="/2018/09/20/css-变形、过渡、动画/rotate.gif" alt="rotate"></p><h3 id="移动（translateX，translateY，translateZ）"><a href="#移动（translateX，translateY，translateZ）" class="headerlink" title="移动（translateX，translateY，translateZ）"></a>移动（translateX，translateY，translateZ）</h3><p>3D移动对于xy方向上的移动与2d移动一致。只有z方向上的移动不一样。Z方向上的移动在现实生活中是距离变远，距离变近。因此在网页中显示结果是变近则变大，变远则变小<br> 要使Z放线上移动生效首先要设置perspective（眼睛距离屏幕的距离）<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> body&#123;</span><br><span class="line">    perspective: 1000px;</span><br><span class="line">    /* 数值越小说明眼睛离的越近 */</span><br><span class="line">&#125;</span><br><span class="line">.translate&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    height: 150px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: #f90;</span><br><span class="line">    transition: all 0.5s;</span><br><span class="line">    margin: 200px auto;</span><br><span class="line">&#125;</span><br><span class="line">.translate:hover&#123;</span><br><span class="line">    transform: translate3d(0, 0, 200px);</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;translate&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>  实现的效果:<br> <img src="/2018/09/20/css-变形、过渡、动画/translate.gif" alt="translate"></p><h1 id="动画-animation"><a href="#动画-animation" class="headerlink" title="动画 animation"></a>动画 animation</h1><p> animation : animation-name || animation-duration || animation-timing-function || animation-delay || animation-iteration-count || animation-direction || animation-fill-mode<br> animation-name : 动画名称（自己使用@keyframes 定义的动画）<br> animation-duration : 持续时间<br> animation-timing-function : 运动曲线，与过渡的运动曲线类似。<br> animation-delay : 延迟时间<br> animation-iteration-count : 循环次数 （infinite 是无限循环）<br> animation-direction　: 是否反向（动画是否是由结尾倒开是倒着放的）<br> animation-fill-mode : 设置在动画播放之外的状态（结束时的状态）none | forwards（设为结束时的状态）| backwards(设为开始时的状态)| both（设为开始或结束时的状态）<br> animation-play-state : 设置动画状态 running 开始 | paused 暂停</p><h3 id="keyframes-自定义动画"><a href="#keyframes-自定义动画" class="headerlink" title="@keyframes 自定义动画"></a>@keyframes 自定义动画</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.animation&#123;</span><br><span class="line">    width: 50px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    background: #f90;</span><br><span class="line">    animation: move 3s linear 2s;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes move &#123;</span><br><span class="line">    0% &#123;</span><br><span class="line">        transform: translate3d(0,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">    25% &#123;</span><br><span class="line">        transform: translate3d(0,150px,0);</span><br><span class="line">    &#125;</span><br><span class="line">    50%&#123;</span><br><span class="line">        transform: translate3d(350px,150px,0);</span><br><span class="line">    &#125;</span><br><span class="line">    75%&#123;</span><br><span class="line">        transform: translate3d(350px,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">    100%&#123;</span><br><span class="line">        transform: translate3d(0,0,0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div class=&quot;animation&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>   实现的效果:<br>  <img src="/2018/09/20/css-变形、过渡、动画/animation.gif" alt="animation"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;过渡-transition&quot;&gt;&lt;a href=&quot;#过渡-transition&quot; class=&quot;headerlink&quot; title=&quot;过渡 ( transition )&quot;&gt;&lt;/a&gt;过渡 ( transition )&lt;/h1&gt;&lt;p&gt;过渡属性用法： transition
      
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="css" scheme="https://Lifuzhen.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>一年的总结</title>
    <link href="https://Lifuzhen.github.io/2018/09/19/%E4%B8%80%E5%B9%B4%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://Lifuzhen.github.io/2018/09/19/一年的总结/</id>
    <published>2018-09-19T10:05:10.000Z</published>
    <updated>2019-05-15T03:59:53.129Z</updated>
    
    <content type="html"><![CDATA[<p>2017-09-18第一天在上海上班，昨天刚好是我入职一周年。</p><p>感觉一年过的好快啊，去年的这一天还历历在目，仿佛像昨天刚过去一样。</p><p>这一年里学到了很多东西，也感觉没学到太多东西（很矛盾）虽然码react代码很熟练了，但是并没有太深入的了解，连源码都没看过不能说熟练应用react。<br>react移动端的东西都没有写过（这方面很欠缺）<br>熟悉了fetch但是ajax都快被我忘光光了！真像狗熊掰棒子，掰一个掉一个！<br>这一年买了很多书，真正读完的到很少（只是看完了几本与技术无关的书籍）。看见想要的书就想买，从来不管买来看不看（我觉得这是病，但是不想治。就这样吧）</p><p>也学到了很多教训，上海地铁上的小偷太多了，来上海没一年被偷了俩手机了！其实我很喜欢我的那个荣耀7手机，那是我在学校利用课余时间兼职挣钱买的一部我最喜欢的手机，现在都没有卖的了（很气）。</p><h1 id="未来一年的计划"><a href="#未来一年的计划" class="headerlink" title="未来一年的计划"></a>未来一年的计划</h1><p> 多读书（保持学习能力，才是未来的安身立命之本）<br> 把自己搭建的框架里面填满代码，多码点代码<br> 考个自己想考的证书（正在奋斗中….）<br> (…….)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2017-09-18第一天在上海上班，昨天刚好是我入职一周年。&lt;/p&gt;
&lt;p&gt;感觉一年过的好快啊，去年的这一天还历历在目，仿佛像昨天刚过去一样。&lt;/p&gt;
&lt;p&gt;这一年里学到了很多东西，也感觉没学到太多东西（很矛盾）虽然码react代码很熟练了，但是并没有太深入的了解，连源码
      
    
    </summary>
    
      <category term="随便写写" scheme="https://Lifuzhen.github.io/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
    
      <category term="随便写写" scheme="https://Lifuzhen.github.io/tags/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>英语</title>
    <link href="https://Lifuzhen.github.io/2018/09/04/%E8%8B%B1%E8%AF%AD/"/>
    <id>https://Lifuzhen.github.io/2018/09/04/英语/</id>
    <published>2018-09-04T10:37:12.000Z</published>
    <updated>2019-05-15T03:59:53.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吐槽一下我的培训班的英语老师"><a href="#吐槽一下我的培训班的英语老师" class="headerlink" title="吐槽一下我的培训班的英语老师"></a>吐槽一下我的培训班的英语老师</h1><p>9月2号我的英语班级开班，去上第一天课。满怀憧憬，提前一天预演了一下我的自我介绍（自我感觉良好，心里美滋滋）。在去上课的地铁上还在纠结到底要不要介绍我什么时候毕业、什么时候工作的要不要辣莫细呢？<br><a id="more"></a><br>教室不是特别大，坐在教室里没一会老师进来了。一直到他开口前面部都没有任何表情（给人一种不苟言笑的感觉），心里默念辣莫高冷。开始让我们自我介绍，让我们分别介绍教育、英文等级、等等。之前根本没有打算介绍教育背景、英文等级，都没有任何准备，打得我一个措手不及。中途还有很多人会日语，老师也用日语跟学生交流（我听不懂，我日语也就只知道五十音图）？？？？介绍完后老师说既然大家都没有太高的等级，就把英语的语速降低点。老师上来真的语速慢了很多（暖暖的很贴心）。</p><p>后来可能是为了调节课堂气氛，讲了一大串英文语速特别快。全程没有听明白说的啥（黑人问好脸）偶尔还会给我们蹦出一大串日语和法语，他是切换的毫无破绽我们也是听得毫无破绽。我都觉得我之前的英文全都白学了。为什么我什么都听不懂，我明明最近一直都在背单词听听力。</p><p>老师的语速快起来真的没边，从没有读过的文章到手就很6666666的语速。</p><p>老师的会的语言真是数不胜数，法语、韩语、日语、英语、四川话、东北话、上海话（其中还包括我很多没有听明白的语言，这些也不是都听出来的，看他朋友圈看到的）他说他之前一起带过英语和日语的培训班（用英语讲日语，佩服的五体投地）</p><p><img src="/2018/09/04/英语/english.jpg" alt="english"></p><p>这是下课后老师在群里给我们发的一段话，当时看到就没往下看了，有点怀疑这是英语吗？然后查字典找单词的意思，勉强翻译出了这句话（心碎了一地）</p><p>打击了我的自信心也激发了我的斗志（加油）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;吐槽一下我的培训班的英语老师&quot;&gt;&lt;a href=&quot;#吐槽一下我的培训班的英语老师&quot; class=&quot;headerlink&quot; title=&quot;吐槽一下我的培训班的英语老师&quot;&gt;&lt;/a&gt;吐槽一下我的培训班的英语老师&lt;/h1&gt;&lt;p&gt;9月2号我的英语班级开班，去上第一天课。满怀憧憬，提前一天预演了一下我的自我介绍（自我感觉良好，心里美滋滋）。在去上课的地铁上还在纠结到底要不要介绍我什么时候毕业、什么时候工作的要不要辣莫细呢？&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="English" scheme="https://Lifuzhen.github.io/categories/English/"/>
    
    
      <category term="English" scheme="https://Lifuzhen.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>json对象遍历</title>
    <link href="https://Lifuzhen.github.io/2018/08/30/json%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86/"/>
    <id>https://Lifuzhen.github.io/2018/08/30/json对象遍历/</id>
    <published>2018-08-30T07:08:36.000Z</published>
    <updated>2019-05-15T03:59:53.128Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/08/30/json对象遍历/autumn.jpg" alt="autumn"><br>之前一直都是对json数组进行操作，顺便看一下(<em>^__^</em>)<br><a id="more"></a></p><h1 id="遍历json对象"><a href="#遍历json对象" class="headerlink" title="遍历json对象"></a>遍历json对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var jsonObj = &#123;&quot;name&quot;: &quot;jeans&quot;, &quot;password&quot;: &quot;1111&quot;&#125;;</span><br><span class="line">for (var val in jsonObj) &#123;</span><br><span class="line">    alert(val + &quot; &quot; + jsonObj[val]);//输出如:name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历json数组，元素为json对象"><a href="#遍历json数组，元素为json对象" class="headerlink" title="遍历json数组，元素为json对象"></a>遍历json数组，元素为json对象</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">## 无规律json数组</span><br><span class="line">var jsonArr = [&#123;&quot;name&quot;:&quot;jeans&quot;,&quot;age&quot;:24,&quot;sex&quot;:&quot;女&quot;,city:&quot;江苏&quot;&#125;,</span><br><span class="line">            &#123;&quot;text&quot;:&quot;shelly&quot;,&quot;content&quot;:123654&#125;];</span><br><span class="line"></span><br><span class="line">for (var i = 0, l = jsonArr.length; i &lt; l; i++) &#123;</span><br><span class="line">    for (var key in jsonArr[i]) &#123;</span><br><span class="line">        alert(key + &apos;:&apos; + jsonArr[i][key]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">## 有规律json数组</span><br><span class="line"></span><br><span class="line">var jsonArr =[</span><br><span class="line">&#123;&quot;name&quot;:&quot;jeans&quot;,&quot;age&quot;:24,&quot;sex&quot;:&quot;女&quot;,city:&quot;江苏&quot;&#125;,</span><br><span class="line">&#123;&quot;name&quot;:&quot;shelly&quot;,&quot;age&quot;:21&#125;,&quot;sex&quot;:&quot;女&quot;,&quot;city&quot;:&quot;上海&quot;&#125;</span><br><span class="line">]</span><br><span class="line">(1)、</span><br><span class="line">for (var p in jsonArr) &#123;//遍历json数组时，这么写p为索引，0,1</span><br><span class="line">    alert(jsonArr[p].name + &quot; &quot; + jsonArr[p].age);</span><br><span class="line">&#125;</span><br><span class="line">(2)、</span><br><span class="line">for(var i = 0; i &lt; jsonArr.length; i++)&#123;</span><br><span class="line">   alert(jsonArr[i].name + &quot; &quot; + jsonArr[i].age);</span><br><span class="line">&#125;</span><br><span class="line">(3)、es6 的 map 方法</span><br><span class="line">const html = jsonArr.map((x)=&gt;&#123;</span><br><span class="line">console.lo(x); //x=&#123;&quot;name&quot;:&quot;jeans&quot;,&quot;age&quot;:24,&quot;sex&quot;:&quot;女&quot;,city:&quot;江苏&quot;&#125;</span><br><span class="line">return &lt;p&gt;名字:&#123;x.name&#125;;年龄:&#123;x.age&#125;;性别:&#123;x.sex&#125;;城市:&#123;x.city&#125;&lt;/p&gt;</span><br><span class="line">&#125;)</span><br><span class="line">//map后的结果插入到页面中就可以了</span><br></pre></td></tr></table></figure><h1 id="深度遍历复合Json结构数据"><a href="#深度遍历复合Json结构数据" class="headerlink" title="深度遍历复合Json结构数据"></a>深度遍历复合Json结构数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON对象里面可以嵌套多层对象(数组或对象)，嵌套层数未知</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 深度遍历</span><br><span class="line"> * 复合的Json结构数据，JSON对象里面可以嵌套多层对象(数组或对象)</span><br><span class="line"> */</span><br><span class="line"> function deepJson(json)&#123;</span><br><span class="line">  // 1. 变量为json对象：将key输出，value进行递归</span><br><span class="line">     if(isType(json, &quot;Object&quot;))&#123;</span><br><span class="line">          for(var key in json)&#123;</span><br><span class="line">           $(&quot;#out&quot;).append(key + &apos; : &apos;);</span><br><span class="line">           if(isType(json[key], &quot;Array&quot;) || isType(json[key], &quot;Object&quot;))&#123;</span><br><span class="line">            $(&quot;#out&quot;).append(&quot;下面为子项内容&lt;br/&gt;&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           deepTraverse(json[key]);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     // 2. 变量为json数组：逐个元素递归</span><br><span class="line">     else if(isType(json, &quot;Array&quot;))&#123;</span><br><span class="line">          for(var i=0; i&lt;json.length; i++)&#123;</span><br><span class="line">               var jsonObj = json[i];</span><br><span class="line">               deepTraverse(jsonObj);</span><br><span class="line">              // 遍历数组中的元素(为json对象)后输出：分隔线+一个换行符</span><br><span class="line">              if(isType(jsonObj, &quot;Object&quot;))&#123;</span><br><span class="line">                $(&quot;#out&quot;).append(&quot;------------------------&lt;br/&gt;&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     // 3. 变量为简单数据类型：直接输出（递归函数的终止条件）</span><br><span class="line">     else if(isType(json, &quot;String&quot;) || isType(json, &quot;Number&quot;) ||</span><br><span class="line">      isType(json,&quot;Boolean&quot;) || isType(json,&quot;Null&quot;))&#123;</span><br><span class="line">          $(&quot;#out&quot;).append(json);</span><br><span class="line">          $(&quot;#out&quot;).append(&quot;&lt;br/&gt;&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/08/30/json对象遍历/autumn.jpg&quot; alt=&quot;autumn&quot;&gt;&lt;br&gt;之前一直都是对json数组进行操作，顺便看一下(&lt;em&gt;^__^&lt;/em&gt;)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://Lifuzhen.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://Lifuzhen.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://Lifuzhen.github.io/2018/08/28/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>https://Lifuzhen.github.io/2018/08/28/第一篇博客/</id>
    <published>2018-08-28T09:46:32.000Z</published>
    <updated>2019-05-15T03:59:53.135Z</updated>
    
    <content type="html"><![CDATA[<p>竟然不知写些什么，只好把我之前写的东西搬出来了</p><h1 id="《摆渡人》"><a href="#《摆渡人》" class="headerlink" title="《摆渡人》"></a>《摆渡人》</h1><p>这本书我几天的片段时间共五个多小时看完了。我没有看的很细致，只是粗略的大概读了一遍。<br><a id="more"></a><br>摆渡人的使命是渡人，但是摆渡人需要怎么渡呢？摆渡或许是相互的。你摆渡我，我摆渡你！<br>迪伦与崔斯坦互相喜欢😍迪伦失去生命时是崔斯坦摆渡了她，按照常理把迪伦送到了她应该去的地方。一路上他们经历磨难，互生好感。迪伦为了跟崔斯坦在一起不惧违背常理返回他们见面的起点，终于他们一起回到了人世。<br>好像是迪伦摆渡了崔斯坦！<br>最后迪伦说了一句，原来你在这里。<br>崔斯坦回，我在这里！<br>有点羡慕他们之间的爱情💏，有什么说什么，不隐藏自己内心的想法！</p><p>读书永远不能荒废，看好多人都是看一些有针对性的书籍，而我就是喜欢一些小说（悬疑、盗墓、警匪）等等<br>我也希望我以后可以多看点技术型的书籍</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;竟然不知写些什么，只好把我之前写的东西搬出来了&lt;/p&gt;
&lt;h1 id=&quot;《摆渡人》&quot;&gt;&lt;a href=&quot;#《摆渡人》&quot; class=&quot;headerlink&quot; title=&quot;《摆渡人》&quot;&gt;&lt;/a&gt;《摆渡人》&lt;/h1&gt;&lt;p&gt;这本书我几天的片段时间共五个多小时看完了。我没有看的很细致，只是粗略的大概读了一遍。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随便写写" scheme="https://Lifuzhen.github.io/categories/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
    
      <category term="随便写写" scheme="https://Lifuzhen.github.io/tags/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>创建了个人博客</title>
    <link href="https://Lifuzhen.github.io/2018/08/27/hello-world/"/>
    <id>https://Lifuzhen.github.io/2018/08/27/hello-world/</id>
    <published>2018-08-27T08:11:22.000Z</published>
    <updated>2019-05-15T03:59:53.127Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到我的个人博客。最近一直在看别人的博客所以也想着弄一个….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;欢迎来到我的个人博客。最近一直在看别人的博客所以也想着弄一个….&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
